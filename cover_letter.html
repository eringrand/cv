<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Erin Grand Cover Letter" />




<meta name="author" content="Erin Grand" />


<meta name="description" content="Erin Grand Cover Letter">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","paged-footnotes":false,"links-to-footnotes":true,"params":{"resume_only":{"value":true},"pdf_mode":{"value":true}},"output":{"pagedown::html_letter":{"self_contained":true,"css":["css/cover_letter.css","letter"]}},"author":"Erin Grand","title":"Erin Grand Cover Letter"}
</script>

<title>Erin Grand Cover Letter</title>


<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = window.location.hash.replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	global.PagedPolyfill = factory();
}(typeof self !== 'undefined' ? self : this, function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n.default || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function"){
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if(element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		let after = node;

		if (after.nextSibling) {
			if (limiter && node === limiter) {
				return;
			}
			after = after.nextSibling;
		} else {
			while (after) {
				after = after.parentNode;
				if (limiter && after === limiter) {
					after = undefined;
					break;
				}
				if (after && after.nextSibling) {
					after = after.nextSibling;
					break;
				}
			}
		}

		return after;
	}

	function nodeBefore(node, limiter) {
		let before = node;
		if (before.previousSibling) {
			if (limiter && node === limiter) {
				return;
			}
			before = before.previousSibling;
		} else {
			while (before) {
				before = before.parentNode;
				if (limiter && before === limiter) {
					before = undefined;
					break;
				}
				if (before && before.previousSibling) {
					before = before.previousSibling;
					break;
				}
			}
		}

		return before;
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after);
		}

		return after;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				(node.dataset.page || node.dataset.afterPage)
			 ) {
			return true;
		}

		return false;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

	  /**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
	  triggerSync(){
	    var args = arguments;
	    var context = this.context;
	    var results = [];

	    this.hooks.forEach(function(task) {
	      var executing = task.apply(context, args);

	      results.push(executing);
	    });


	    return results;
	  }

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, maxChars) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.maxChars = maxChars || MAX_CHARS_PER_BREAK;
		}

		async renderTo(wrapper, source, breakToken, bounds=this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			while (!done && !newBreakToken) {
				next = walker.next();
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset=0) {
			return {
				node,
				offset
			};
		}

		shouldBreak(node) {
			let previousSibling = node.previousSibling;
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node);
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow=true, rebuild=true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function() {
						let { width, height } = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function(e) {
						let { width, height } = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let { width, height } = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if(window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						renderedNode = findElement(prevValidNode(temp), rendered);
						return;
					}

					node = findElement(renderedNode, source);
					offset = 0;
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					node = child(parent, index);
					offset = 0;
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return {
				node,
				offset
			};

		}

		findBreakToken(rendered, source, bounds=this.bounds, extract=true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);

				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});


				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds=this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let { width } = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds=this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end =  Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.floor(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						if (isElement(node) ) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.setStartBefore(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.setStartBefore(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.setStartBefore(node);
							break;
						}

					}

					if (!range && isText(node) &&
							node.textContent.trim().length &&
							window.getComputedStyle(node.parentNode)["break-inside"] !== "avoid") {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if(left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right < end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds=this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if(!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer);

			return extracted;
		}

		hyphenateAtBreak(startContainer) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length-1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (/^\w|\u00AD$/.test(prevLetter)) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += "\u2011";
				}
			}
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum+1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute('id', id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if(e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function() {
				if(this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element &&this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver( entries => {

				if (!this.listening) {
					return;
				}

				for (let entry of entries) {
					const cr = entry.contentRect;

					if (cr.height > prevHeight) {
						this.checkOverflowAfterResize(contents);
						prevHeight = wrapper.getBoundingClientRect().height;
					} else if (cr.height < prevHeight ) { // TODO: calc line height && (prevHeight - cr.height) >= 22
						this.checkUnderflowAfterResize(contents);
						prevHeight = cr.height;
					}
				}
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			// let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);
			this.removeEmpty(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);
			this.removeEmpty(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				{ acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		removeEmpty(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_TEXT,
				{ acceptNode: function(node) {
					// Only remove more than a single space
					if (node.textContent.length > 1 && !node.textContent.trim()) {

						// Don't touch whitespace if text is preformated
						let parent = node.parentNode;
						let pre = isElement(parent) && parent.closest("pre");
						if (pre) {
							return NodeFilter.FILTER_REJECT;
						}

						return NodeFilter.FILTER_ACCEPT;
					} else {
						return NodeFilter.FILTER_REJECT;
					}
				} },
				false
			);

			let node;
			let current;
			node = treeWalker.nextNode();
			while(node) {
				current = node;
				node = treeWalker.nextNode();
				// if (!current.nextSibling || (current.nextSibling && current.nextSibling.nodeType === 1)) {
				current.parentNode.removeChild(current);
				// }
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		// isWrapper(element) {
		//   return wrappersRegex.test(element.nodeName);
		// }

		isText(node) {
			return node.tagName === "TAG";
		}

		isElement(node) {
			return node.nodeType === 1;
		}

		hasChildren(node) {
			return node.childNodes && node.childNodes.length;
		}


		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo) {
			// this.preview = preview;

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this._total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", content);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);

			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt);

			let done = false;
			let result;

			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && (true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}
		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/

		get total() {
			return this._total;
		}

		set total(num) {
			this.pagesArea.style.setProperty("--pagedjs-page-count", num);
			this._total = num;
		}

		loadFonts() {
			let fontPromises = [];
			document.fonts.forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//            item        item        item        item
	//          /------\    /------\    /------\    /------\
	//          | data |    | data |    | data |    | data |
	//  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |
	//          | next-+--->| next-+--->| next-+--->| next-+--> null
	//          \------/    \------/    \------/    \------/
	//             ^                                    ^
	//             |                list                |
	//             |              /------\              |
	//             \--------------+-head |              |
	//                            | tail-+--------------/
	//                            \------/
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var list = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var CssSyntaxError = function(message, source, offset, line, column) {
	    var error = createCustomError('CssSyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var error = CssSyntaxError;

	// token types (note: value shouldn't intersect with used char codes)
	var WHITESPACE = 1;
	var IDENTIFIER = 2;
	var NUMBER = 3;
	var STRING = 4;
	var COMMENT = 5;
	var PUNCTUATOR = 6;
	var CDO = 7;
	var CDC = 8;
	var ATKEYWORD = 14;
	var FUNCTION = 15;
	var URL$1 = 16;
	var RAW = 17;

	var TAB = 9;
	var N = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var TYPE = {
	    WhiteSpace:   WHITESPACE,
	    Identifier:   IDENTIFIER,
	    Number:           NUMBER,
	    String:           STRING,
	    Comment:         COMMENT,
	    Punctuator:   PUNCTUATOR,
	    CDO:                 CDO,
	    CDC:                 CDC,
	    AtKeyword:     ATKEYWORD,
	    Function:       FUNCTION,
	    Url:                 URL$1,
	    Raw:                 RAW,

	    ExclamationMark:      33,  // !
	    QuotationMark:        34,  // "
	    NumberSign:           35,  // #
	    DollarSign:           36,  // $
	    PercentSign:          37,  // %
	    Ampersand:            38,  // &
	    Apostrophe:           39,  // '
	    LeftParenthesis:      40,  // (
	    RightParenthesis:     41,  // )
	    Asterisk:             42,  // *
	    PlusSign:             43,  // +
	    Comma:                44,  // ,
	    HyphenMinus:          45,  // -
	    FullStop:             46,  // .
	    Solidus:              47,  // /
	    Colon:                58,  // :
	    Semicolon:            59,  // ;
	    LessThanSign:         60,  // <
	    EqualsSign:           61,  // =
	    GreaterThanSign:      62,  // >
	    QuestionMark:         63,  // ?
	    CommercialAt:         64,  // @
	    LeftSquareBracket:    91,  // [
	    Backslash:            92,  // \
	    RightSquareBracket:   93,  // ]
	    CircumflexAccent:     94,  // ^
	    LowLine:              95,  // _
	    GraveAccent:          96,  // `
	    LeftCurlyBracket:    123,  // {
	    VerticalLine:        124,  // |
	    RightCurlyBracket:   125,  // }
	    Tilde:               126   // ~
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we a maps for 0..127 codes only
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported
	var SYMBOL_TYPE = new SafeUint32Array(0x80);
	var PUNCTUATION = new SafeUint32Array(0x80);
	var STOP_URL_RAW = new SafeUint32Array(0x80);

	for (var i = 0; i < SYMBOL_TYPE.length; i++) {
	    SYMBOL_TYPE[i] = IDENTIFIER;
	}

	// fill categories
	[
	    TYPE.ExclamationMark,    // !
	    TYPE.QuotationMark,      // "
	    TYPE.NumberSign,         // #
	    TYPE.DollarSign,         // $
	    TYPE.PercentSign,        // %
	    TYPE.Ampersand,          // &
	    TYPE.Apostrophe,         // '
	    TYPE.LeftParenthesis,    // (
	    TYPE.RightParenthesis,   // )
	    TYPE.Asterisk,           // *
	    TYPE.PlusSign,           // +
	    TYPE.Comma,              // ,
	    TYPE.HyphenMinus,        // -
	    TYPE.FullStop,           // .
	    TYPE.Solidus,            // /
	    TYPE.Colon,              // :
	    TYPE.Semicolon,          // ;
	    TYPE.LessThanSign,       // <
	    TYPE.EqualsSign,         // =
	    TYPE.GreaterThanSign,    // >
	    TYPE.QuestionMark,       // ?
	    TYPE.CommercialAt,       // @
	    TYPE.LeftSquareBracket,  // [
	    // TYPE.Backslash,          // \
	    TYPE.RightSquareBracket, // ]
	    TYPE.CircumflexAccent,   // ^
	    // TYPE.LowLine,            // _
	    TYPE.GraveAccent,        // `
	    TYPE.LeftCurlyBracket,   // {
	    TYPE.VerticalLine,       // |
	    TYPE.RightCurlyBracket,  // }
	    TYPE.Tilde               // ~
	].forEach(function(key) {
	    SYMBOL_TYPE[Number(key)] = PUNCTUATOR;
	    PUNCTUATION[Number(key)] = PUNCTUATOR;
	});

	for (var i = 48; i <= 57; i++) {
	    SYMBOL_TYPE[i] = NUMBER;
	}

	SYMBOL_TYPE[SPACE] = WHITESPACE;
	SYMBOL_TYPE[TAB] = WHITESPACE;
	SYMBOL_TYPE[N] = WHITESPACE;
	SYMBOL_TYPE[R] = WHITESPACE;
	SYMBOL_TYPE[F] = WHITESPACE;

	SYMBOL_TYPE[TYPE.Apostrophe] = STRING;
	SYMBOL_TYPE[TYPE.QuotationMark] = STRING;

	STOP_URL_RAW[SPACE] = 1;
	STOP_URL_RAW[TAB] = 1;
	STOP_URL_RAW[N] = 1;
	STOP_URL_RAW[R] = 1;
	STOP_URL_RAW[F] = 1;
	STOP_URL_RAW[TYPE.Apostrophe] = 1;
	STOP_URL_RAW[TYPE.QuotationMark] = 1;
	STOP_URL_RAW[TYPE.LeftParenthesis] = 1;
	STOP_URL_RAW[TYPE.RightParenthesis] = 1;

	// whitespace is punctuation ...
	PUNCTUATION[SPACE] = PUNCTUATOR;
	PUNCTUATION[TAB] = PUNCTUATOR;
	PUNCTUATION[N] = PUNCTUATOR;
	PUNCTUATION[R] = PUNCTUATOR;
	PUNCTUATION[F] = PUNCTUATOR;
	// ... hyper minus is not
	PUNCTUATION[TYPE.HyphenMinus] = 0;

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME,

	    SYMBOL_TYPE: SYMBOL_TYPE,
	    PUNCTUATION: PUNCTUATION,
	    STOP_URL_RAW: STOP_URL_RAW
	};

	var PUNCTUATION$1 = _const.PUNCTUATION;
	var STOP_URL_RAW$1 = _const.STOP_URL_RAW;
	var TYPE$1 = _const.TYPE;
	var FULLSTOP = TYPE$1.FullStop;
	var PLUSSIGN = TYPE$1.PlusSign;
	var HYPHENMINUS = TYPE$1.HyphenMinus;
	var PUNCTUATOR$1 = TYPE$1.Punctuator;
	var TAB$1 = 9;
	var N$1 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var BACK_SLASH = 92;
	var E = 101; // 'e'.charCodeAt(0)

	function firstCharOffset(source) {
	    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	    if (source.charCodeAt(0) === 0xFEFF ||  // UTF-16BE
	        source.charCodeAt(0) === 0xFFFE) {  // UTF-16LE
	        return 1;
	    }

	    return 0;
	}

	function isHex(code) {
	    return (code >= 48 && code <= 57) || // 0 .. 9
	           (code >= 65 && code <= 70) || // A .. F
	           (code >= 97 && code <= 102);  // a .. f
	}

	function isNumber(code) {
	    return code >= 48 && code <= 57;
	}

	function isWhiteSpace(code) {
	    return code === SPACE$1 || code === TAB$1 || isNewline(code);
	}

	function isNewline(code) {
	    return code === R$1 || code === N$1 || code === F$1;
	}

	function getNewlineLength(source, offset, code) {
	    if (isNewline(code)) {
	        if (code === R$1 && offset + 1 < source.length && source.charCodeAt(offset + 1) === N$1) {
	            return 2;
	        }

	        return 1;
	    }

	    return 0;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (code >= 65 && code <= 90) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var refCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (testCode >= 65 && testCode <= 90) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== refCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    while (offset >= 0 && isWhiteSpace(source.charCodeAt(offset))) {
	        offset--;
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    while (offset < source.length && isWhiteSpace(source.charCodeAt(offset))) {
	        offset++;
	    }

	    return offset;
	}

	function findCommentEnd(source, offset) {
	    var commentEnd = source.indexOf('*/', offset);

	    if (commentEnd === -1) {
	        return source.length;
	    }

	    return commentEnd + 2;
	}

	function findStringEnd(source, offset, quote) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // TODO: bad string
	        if (code === BACK_SLASH) {
	            offset++;
	        } else if (code === quote) {
	            offset++;
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    while (offset < source.length && isNumber(source.charCodeAt(offset))) {
	        offset++;
	    }

	    return offset;
	}

	function findNumberEnd(source, offset, allowFraction) {
	    var code;

	    offset = findDecimalNumberEnd(source, offset);

	    // fraction: .\d+
	    if (allowFraction && offset + 1 < source.length && source.charCodeAt(offset) === FULLSTOP) {
	        code = source.charCodeAt(offset + 1);

	        if (isNumber(code)) {
	            offset = findDecimalNumberEnd(source, offset + 1);
	        }
	    }

	    // exponent: e[+-]\d+
	    if (offset + 1 < source.length) {
	        if ((source.charCodeAt(offset) | 32) === E) { // case insensitive check for `e`
	            code = source.charCodeAt(offset + 1);

	            if (code === PLUSSIGN || code === HYPHENMINUS) {
	                if (offset + 2 < source.length) {
	                    code = source.charCodeAt(offset + 2);
	                }
	            }

	            if (isNumber(code)) {
	                offset = findDecimalNumberEnd(source, offset + 2);
	            }
	        }
	    }

	    return offset;
	}

	// skip escaped unicode sequence that can ends with space
	// [0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
	function findEscapeEnd(source, offset) {
	    for (var i = 0; i < 7 && offset + i < source.length; i++) {
	        var code = source.charCodeAt(offset + i);

	        if (i !== 6 && isHex(code)) {
	            continue;
	        }

	        if (i > 0) {
	            offset += i - 1 + getNewlineLength(source, offset + i, code);
	            if (code === SPACE$1 || code === TAB$1) {
	                offset++;
	            }
	        }

	        break;
	    }

	    return offset;
	}

	function findIdentifierEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        if (code === BACK_SLASH) {
	            offset = findEscapeEnd(source, offset + 1);
	        } else if (code < 0x80 && PUNCTUATION$1[code] === PUNCTUATOR$1) {
	            break;
	        }
	    }

	    return offset;
	}

	function findUrlRawEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        if (code === BACK_SLASH) {
	            offset = findEscapeEnd(source, offset + 1);
	        } else if (code < 0x80 && STOP_URL_RAW$1[code] === 1) {
	            break;
	        }
	    }

	    return offset;
	}

	var utils = {
	    firstCharOffset: firstCharOffset,

	    isHex: isHex,
	    isNumber: isNumber,
	    isWhiteSpace: isWhiteSpace,
	    isNewline: isNewline,
	    getNewlineLength: getNewlineLength,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd,
	    findCommentEnd: findCommentEnd,
	    findStringEnd: findStringEnd,
	    findDecimalNumberEnd: findDecimalNumberEnd,
	    findNumberEnd: findNumberEnd,
	    findEscapeEnd: findEscapeEnd,
	    findIdentifierEnd: findIdentifierEnd,
	    findUrlRawEnd: findUrlRawEnd
	};

	var TYPE$2 = _const.TYPE;
	var NAME$1 = _const.NAME;
	var SYMBOL_TYPE$1 = _const.SYMBOL_TYPE;


	var firstCharOffset$1 = utils.firstCharOffset;
	var cmpStr$1 = utils.cmpStr;
	var isNumber$1 = utils.isNumber;
	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var findCommentEnd$1 = utils.findCommentEnd;
	var findStringEnd$1 = utils.findStringEnd;
	var findNumberEnd$1 = utils.findNumberEnd;
	var findIdentifierEnd$1 = utils.findIdentifierEnd;
	var findUrlRawEnd$1 = utils.findUrlRawEnd;

	var NULL = 0;
	var WHITESPACE$1 = TYPE$2.WhiteSpace;
	var IDENTIFIER$1 = TYPE$2.Identifier;
	var NUMBER$1 = TYPE$2.Number;
	var STRING$1 = TYPE$2.String;
	var COMMENT$1 = TYPE$2.Comment;
	var PUNCTUATOR$2 = TYPE$2.Punctuator;
	var CDO$1 = TYPE$2.CDO;
	var CDC$1 = TYPE$2.CDC;
	var ATKEYWORD$1 = TYPE$2.AtKeyword;
	var FUNCTION$1 = TYPE$2.Function;
	var URL$2 = TYPE$2.Url;
	var RAW$1 = TYPE$2.Raw;

	var N$2 = 10;
	var F$2 = 12;
	var R$2 = 13;
	var STAR = TYPE$2.Asterisk;
	var SLASH = TYPE$2.Solidus;
	var FULLSTOP$1 = TYPE$2.FullStop;
	var PLUSSIGN$1 = TYPE$2.PlusSign;
	var HYPHENMINUS$1 = TYPE$2.HyphenMinus;
	var GREATERTHANSIGN = TYPE$2.GreaterThanSign;
	var LESSTHANSIGN = TYPE$2.LessThanSign;
	var EXCLAMATIONMARK = TYPE$2.ExclamationMark;
	var COMMERCIALAT = TYPE$2.CommercialAt;
	var QUOTATIONMARK = TYPE$2.QuotationMark;
	var APOSTROPHE = TYPE$2.Apostrophe;
	var LEFTPARENTHESIS = TYPE$2.LeftParenthesis;
	var RIGHTPARENTHESIS = TYPE$2.RightParenthesis;
	var LEFTCURLYBRACKET = TYPE$2.LeftCurlyBracket;
	var RIGHTCURLYBRACKET = TYPE$2.RightCurlyBracket;
	var LEFTSQUAREBRACKET = TYPE$2.LeftSquareBracket;
	var RIGHTSQUAREBRACKET = TYPE$2.RightSquareBracket;

	var MIN_BUFFER_SIZE = 16 * 1024;
	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;
	var SafeUint32Array$1 = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	function computeLinesAndColumns(tokenizer, source) {
	    var sourceLength = source.length;
	    var start = firstCharOffset$1(source);
	    var lines = tokenizer.lines;
	    var line = tokenizer.startLine;
	    var columns = tokenizer.columns;
	    var column = tokenizer.startColumn;

	    if (lines === null || lines.length < sourceLength + 1) {
	        lines = new SafeUint32Array$1(Math.max(sourceLength + 1024, MIN_BUFFER_SIZE));
	        columns = new SafeUint32Array$1(lines.length);
	    }

	    for (var i = start; i < sourceLength; i++) {
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$2 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$2) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    tokenizer.linesAnsColumnsComputed = true;
	    tokenizer.lines = lines;
	    tokenizer.columns = columns;
	}

	function tokenLayout(tokenizer, source, startPos) {
	    var sourceLength = source.length;
	    var offsetAndType = tokenizer.offsetAndType;
	    var balance = tokenizer.balance;
	    var tokenCount = 0;
	    var prevType = 0;
	    var offset = startPos;
	    var anchor = 0;
	    var balanceCloseCode = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    if (offsetAndType === null || offsetAndType.length < sourceLength + 1) {
	        offsetAndType = new SafeUint32Array$1(sourceLength + 1024);
	        balance = new SafeUint32Array$1(sourceLength + 1024);
	    }

	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = code < 0x80 ? SYMBOL_TYPE$1[code] : IDENTIFIER$1;

	        balance[tokenCount] = sourceLength;

	        switch (type) {
	            case WHITESPACE$1:
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            case PUNCTUATOR$2:
	                switch (code) {
	                    case balanceCloseCode:
	                        balancePrev = balanceStart & OFFSET_MASK;
	                        balanceStart = balance[balancePrev];
	                        balanceCloseCode = balanceStart >> TYPE_SHIFT;
	                        balance[tokenCount] = balancePrev;
	                        balance[balancePrev++] = tokenCount;
	                        for (; balancePrev < tokenCount; balancePrev++) {
	                            if (balance[balancePrev] === sourceLength) {
	                                balance[balancePrev] = tokenCount;
	                            }
	                        }
	                        break;

	                    case LEFTSQUAREBRACKET:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTSQUAREBRACKET;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;

	                    case LEFTCURLYBRACKET:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTCURLYBRACKET;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;

	                    case LEFTPARENTHESIS:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTPARENTHESIS;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;
	                }

	                // /*
	                if (code === STAR && prevType === SLASH) {
	                    type = COMMENT$1;
	                    offset = findCommentEnd$1(source, offset + 1);
	                    tokenCount--; // rewrite prev token
	                    break;
	                }

	                // edge case for -.123 and +.123
	                if (code === FULLSTOP$1 && (prevType === PLUSSIGN$1 || prevType === HYPHENMINUS$1)) {
	                    if (offset + 1 < sourceLength && isNumber$1(source.charCodeAt(offset + 1))) {
	                        type = NUMBER$1;
	                        offset = findNumberEnd$1(source, offset + 2, false);
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // <!--
	                if (code === EXCLAMATIONMARK && prevType === LESSTHANSIGN) {
	                    if (offset + 2 < sourceLength &&
	                        source.charCodeAt(offset + 1) === HYPHENMINUS$1 &&
	                        source.charCodeAt(offset + 2) === HYPHENMINUS$1) {
	                        type = CDO$1;
	                        offset = offset + 3;
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // -->
	                if (code === HYPHENMINUS$1 && prevType === HYPHENMINUS$1) {
	                    if (offset + 1 < sourceLength && source.charCodeAt(offset + 1) === GREATERTHANSIGN) {
	                        type = CDC$1;
	                        offset = offset + 2;
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // ident(
	                if (code === LEFTPARENTHESIS && prevType === IDENTIFIER$1) {
	                    offset = offset + 1;
	                    tokenCount--; // rewrite prev token
	                    balance[tokenCount] = balance[tokenCount + 1];
	                    balanceStart--;

	                    // 4 char length identifier and equal to `url(` (case insensitive)
	                    if (offset - anchor === 4 && cmpStr$1(source, anchor, offset, 'url(')) {
	                        // special case for url() because it can contain any symbols sequence with few exceptions
	                        anchor = findWhiteSpaceEnd$1(source, offset);
	                        code = source.charCodeAt(anchor);
	                        if (code !== LEFTPARENTHESIS &&
	                            code !== RIGHTPARENTHESIS &&
	                            code !== QUOTATIONMARK &&
	                            code !== APOSTROPHE) {
	                            // url(
	                            offsetAndType[tokenCount++] = (URL$2 << TYPE_SHIFT) | offset;
	                            balance[tokenCount] = sourceLength;

	                            // ws*
	                            if (anchor !== offset) {
	                                offsetAndType[tokenCount++] = (WHITESPACE$1 << TYPE_SHIFT) | anchor;
	                                balance[tokenCount] = sourceLength;
	                            }

	                            // raw
	                            type = RAW$1;
	                            offset = findUrlRawEnd$1(source, anchor);
	                        } else {
	                            type = URL$2;
	                        }
	                    } else {
	                        type = FUNCTION$1;
	                    }
	                    break;
	                }

	                type = code;
	                offset = offset + 1;
	                break;

	            case NUMBER$1:
	                offset = findNumberEnd$1(source, offset + 1, prevType !== FULLSTOP$1);

	                // merge number with a preceding dot, dash or plus
	                if (prevType === FULLSTOP$1 ||
	                    prevType === HYPHENMINUS$1 ||
	                    prevType === PLUSSIGN$1) {
	                    tokenCount--; // rewrite prev token
	                }

	                break;

	            case STRING$1:
	                offset = findStringEnd$1(source, offset + 1, code);
	                break;

	            default:
	                anchor = offset;
	                offset = findIdentifierEnd$1(source, offset);

	                // merge identifier with a preceding dash
	                if (prevType === HYPHENMINUS$1) {
	                    // rewrite prev token
	                    tokenCount--;
	                    // restore prev prev token type
	                    // for case @-prefix-ident
	                    prevType = tokenCount === 0 ? 0 : offsetAndType[tokenCount - 1] >> TYPE_SHIFT;
	                }

	                if (prevType === COMMERCIALAT) {
	                    // rewrite prev token and change type to <at-keyword-token>
	                    tokenCount--;
	                    type = ATKEYWORD$1;
	                }
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
	        prevType = type;
	    }

	    // finalize arrays
	    offsetAndType[tokenCount] = offset;
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    tokenizer.offsetAndType = offsetAndType;
	    tokenizer.tokenCount = tokenCount;
	    tokenizer.balance = balance;
	}

	//
	// tokenizer
	//

	var Tokenizer = function(source, startOffset, startLine, startColumn) {
	    this.offsetAndType = null;
	    this.balance = null;
	    this.lines = null;
	    this.columns = null;

	    this.setSource(source, startOffset, startLine, startColumn);
	};

	Tokenizer.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        var safeSource = String(source || '');
	        var start = firstCharOffset$1(safeSource);

	        this.source = safeSource;
	        this.firstCharOffset = start;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAnsColumnsComputed = false;

	        this.eof = false;
	        this.currentToken = -1;
	        this.tokenType = 0;
	        this.tokenStart = start;
	        this.tokenEnd = start;

	        tokenLayout(this, safeSource, start);
	        this.next();
	    },

	    lookupType: function(offset) {
	        offset += this.currentToken;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return NULL;
	    },
	    lookupNonWSType: function(offset) {
	        offset += this.currentToken;

	        for (var type; offset < this.tokenCount; offset++) {
	            type = this.offsetAndType[offset] >> TYPE_SHIFT;

	            if (type !== WHITESPACE$1) {
	                return type;
	            }
	        }

	        return NULL;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.currentToken;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenNum) {
	        if (tokenNum === this.currentToken) {
	            return this.tokenStart;
	        }

	        if (tokenNum > 0) {
	            return tokenNum < this.tokenCount
	                ? this.offsetAndType[tokenNum - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },
	    getOffsetExcludeWS: function() {
	        if (this.currentToken > 0) {
	            if ((this.offsetAndType[this.currentToken - 1] >> TYPE_SHIFT) === WHITESPACE$1) {
	                return this.currentToken > 1
	                    ? this.offsetAndType[this.currentToken - 2] & OFFSET_MASK
	                    : this.firstCharOffset;
	            }
	        }
	        return this.tokenStart;
	    },
	    getRawLength: function(startToken, endTokenType1, endTokenType2, includeTokenType2) {
	        var cursor = startToken;
	        var balanceEnd;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // belance end points to offset before start
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            // check token is stop type
	            switch (this.offsetAndType[cursor] >> TYPE_SHIFT) {
	                case endTokenType1:
	                    break loop;

	                case endTokenType2:
	                    if (includeTokenType2) {
	                        cursor++;
	                    }
	                    break loop;

	                default:
	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }

	        }

	        return cursor - this.currentToken;
	    },
	    isBalanceEdge: function(pos) {
	        var balanceStart = this.balance[this.currentToken];
	        return balanceStart < pos;
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.currentToken, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE$1) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE$1 || this.tokenType === COMMENT$1) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.currentToken + tokenCount;

	        if (next < this.tokenCount) {
	            this.currentToken = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.currentToken = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.currentToken + 1;

	        if (next < this.tokenCount) {
	            this.currentToken = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.currentToken = this.tokenCount;
	            this.eof = true;
	            this.tokenType = NULL;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    eat: function(tokenType) {
	        if (this.tokenType !== tokenType) {
	            var offset = this.tokenStart;
	            var message = NAME$1[tokenType] + ' is expected';

	            // tweak message and offset
	            if (tokenType === IDENTIFIER$1) {
	                // when identifier is expected but there is a function or url
	                if (this.tokenType === FUNCTION$1 || this.tokenType === URL$2) {
	                    offset = this.tokenEnd - 1;
	                    message += ' but function found';
	                }
	            } else {
	                // when test type is part of another token show error for current position + 1
	                // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                if (this.source.charCodeAt(this.tokenStart) === tokenType) {
	                    offset = offset + 1;
	                }
	            }

	            this.error(message, offset);
	        }

	        this.next();
	    },
	    eatNonWS: function(tokenType) {
	        this.skipWS();
	        this.eat(tokenType);
	    },

	    consume: function(tokenType) {
	        var value = this.getTokenValue();

	        this.eat(tokenType);

	        return value;
	    },
	    consumeFunctionName: function() {
	        var name = this.source.substring(this.tokenStart, this.tokenEnd - 1);

	        this.eat(FUNCTION$1);

	        return name;
	    },
	    consumeNonWS: function(tokenType) {
	        this.skipWS();

	        return this.consume(tokenType);
	    },

	    expectIdentifier: function(name) {
	        if (this.tokenType !== IDENTIFIER$1 || cmpStr$1(this.source, this.tokenStart, this.tokenEnd, name) === false) {
	            this.error('Identifier `' + name + '` is expected');
	        }

	        this.next();
	    },

	    getLocation: function(offset, filename) {
	        if (!this.linesAnsColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	        }

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },

	    getLocationRange: function(start, end, filename) {
	        if (!this.linesAnsColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	        }

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    },

	    error: function(message, offset) {
	        var location = typeof offset !== 'undefined' && offset < this.source.length
	            ? this.getLocation(offset)
	            : this.eof
	                ? this.getLocation(findWhiteSpaceStart$1(this.source, this.source.length - 1))
	                : this.getLocation(this.tokenStart);

	        throw new error(
	            message || 'Unexpected input',
	            this.source,
	            location.offset,
	            location.line,
	            location.column
	        );
	    },

	    dump: function() {
	        var offset = 0;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	// extend with error class
	Tokenizer.CssSyntaxError = error;

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    Tokenizer[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(utils).forEach(function(key) {
	    Tokenizer[key] = utils[key];
	});

	// warm up tokenizer to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	new Tokenizer('\n\r\r\n\f<!---->//""\'\'/*\r\n\f*/1a;.\\31\t\+2{url(a);func();+1.2e3 -.4e-5 .6e+7}').getLocation();

	var Tokenizer_1 = Tokenizer;

	var tokenizer = Tokenizer_1;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateSequence(node, forceBraces, decorate) {
	    var result = node.terms.map(function(term) {
	        return generate(term, forceBraces, decorate);
	    }).join(node.combinator === ' ' ? ' ' : ' ' + node.combinator + ' ');

	    if (node.explicit || forceBraces) {
	        result = (result[0] !== ',' ? '[ ' : '[') + result + ' ]';
	    }

	    return result;
	}

	function generate(node, forceBraces, decorate) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, forceBraces, decorate) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, forceBraces, decorate) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, forceBraces, decorate);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = 0;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    if (node === null) {
	        mismatchOffset = css.length;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, lexer, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error$1 = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS$2 = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS$2 &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS$2;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS$2 &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS$2) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var findIdentifierEnd$2 = utils.findIdentifierEnd;
	var findNumberEnd$2 = utils.findNumberEnd;
	var findDecimalNumberEnd$1 = utils.findDecimalNumberEnd;
	var isHex$1 = utils.isHex;

	var SYMBOL_TYPE$2 = _const.SYMBOL_TYPE;
	var IDENTIFIER$2 = _const.TYPE.Identifier;
	var PLUSSIGN$2 = _const.TYPE.PlusSign;
	var HYPHENMINUS$3 = _const.TYPE.HyphenMinus;
	var NUMBERSIGN = _const.TYPE.NumberSign;

	var PERCENTAGE = {
	    '%': true
	};

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	function consumeFunction(token, addTokenToMatch, getNextToken) {
	    var length = 1;
	    var cursor;

	    do {
	        cursor = getNextToken(length++);
	    } while (cursor !== null && cursor.node !== token.node);

	    if (cursor === null) {
	        return false;
	    }

	    while (true) {
	        // consume tokens until cursor
	        if (addTokenToMatch() === cursor) {
	            break;
	        }
	    }

	    return true;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(token, addTokenToMatch, getNextToken) {
	    if (token === null) {
	        return false;
	    }

	    var name = token.value.toLowerCase();
	    if (name !== 'calc(' &&
	        name !== '-moz-calc(' &&
	        name !== '-webkit-calc(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function attr$1(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'attr(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function expression(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'expression(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function url(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'url(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function idSelector(token, addTokenToMatch) {
	    if (token === null) {
	        return false;
	    }

	    if (token.value.charCodeAt(0) !== NUMBERSIGN) {
	        return false;
	    }

	    if (consumeIdentifier(token.value, 1) !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function isNumber$2(str) {
	    return /^[-+]?(\d+|\d*\.\d+)([eE][-+]?\d+)?$/.test(str);
	}

	function consumeNumber(str, allowFraction) {
	    var code = str.charCodeAt(0);

	    return findNumberEnd$2(str, code === PLUSSIGN$2 || code === HYPHENMINUS$3 ? 1 : 0, allowFraction);
	}

	function consumeIdentifier(str, offset) {
	    var code = str.charCodeAt(offset);

	    if (code < 0x80 && SYMBOL_TYPE$2[code] !== IDENTIFIER$2 && code !== HYPHENMINUS$3) {
	        return offset;
	    }

	    return findIdentifierEnd$2(str, offset + 1);
	}

	function astNode(type) {
	    return function(token, addTokenToMatch) {
	        if (token === null || token.node.type !== type) {
	            return false;
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function dimension(type) {
	    return function(token, addTokenToMatch, getNextToken) {
	        if (calc(token, addTokenToMatch, getNextToken)) {
	            return true;
	        }

	        if (token === null) {
	            return false;
	        }

	        var numberEnd = consumeNumber(token.value, true);
	        if (numberEnd === 0) {
	            return false;
	        }

	        if (type) {
	            if (!type.hasOwnProperty(token.value.substr(numberEnd).toLowerCase())) {
	                return false;
	            }
	        } else {
	            var unitEnd = consumeIdentifier(token.value, numberEnd);
	            if (unitEnd === numberEnd || unitEnd !== token.value.length) {
	                return false;
	            }
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function zeroUnitlessDimension(type) {
	    var isDimension = dimension(type);

	    return function(token, addTokenToMatch, getNextToken) {
	        if (isDimension(token, addTokenToMatch, getNextToken)) {
	            return true;
	        }

	        if (token === null || Number(token.value) !== 0) {
	            return false;
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function number(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = consumeNumber(token.value, true);
	    if (numberEnd !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function numberZeroOne(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null || !isNumber$2(token.value)) {
	        return false;
	    }

	    var value = Number(token.value);
	    if (value < 0 || value > 1) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function numberOneOrGreater(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null || !isNumber$2(token.value)) {
	        return false;
	    }

	    var value = Number(token.value);
	    if (value < 1) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	// TODO: fail on 10e-2
	function integer(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = consumeNumber(token.value, false);
	    if (numberEnd !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	// TODO: fail on 10e-2
	function positiveInteger(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = findDecimalNumberEnd$1(token.value, 0);
	    if (numberEnd !== token.value.length || token.value.charCodeAt(0) === HYPHENMINUS$3) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function hexColor(token, addTokenToMatch) {
	    if (token === null || token.value.charCodeAt(0) !== NUMBERSIGN) {
	        return false;
	    }

	    var length = token.value.length - 1;

	    // valid length is 3, 4, 6 and 8 (+1 for #)
	    if (length !== 3 && length !== 4 && length !== 6 && length !== 8) {
	        return false;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHex$1(token.value.charCodeAt(i))) {
	            return false;
	        }
	    }

	    addTokenToMatch();
	    return true;
	}

	// https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	// https://drafts.csswg.org/css-values-4/#identifier-value
	function customIdent(token, addTokenToMatch) {
	    if (token === null) {
	        return false;
	    }

	    var identEnd = consumeIdentifier(token.value, 0);
	    if (identEnd !== token.value.length) {
	        return false;
	    }

	    var name = token.value.toLowerCase();

	    // § 3.2. Author-defined Identifiers: the <custom-ident> type
	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (name === 'unset' || name === 'initial' || name === 'inherit') {
	        return false;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (name === 'default') {
	        return false;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)

	    addTokenToMatch();
	    return true;
	}

	var generic = {
	    'angle': zeroUnitlessDimension(ANGLE),
	    'attr()': attr$1,
	    'custom-ident': customIdent,
	    'decibel': dimension(DECIBEL),
	    'dimension': dimension(),
	    'frequency': dimension(FREQUENCY),
	    'flex': dimension(FLEX),
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'ident': astNode('Identifier'),
	    'integer': integer,
	    'length': zeroUnitlessDimension(LENGTH),
	    'number': number,
	    'number-zero-one': numberZeroOne,
	    'number-one-or-greater': numberOneOrGreater,
	    'percentage': dimension(PERCENTAGE),
	    'positive-integer': positiveInteger,
	    'resolution': dimension(RESOLUTION),
	    'semitones': dimension(SEMITONES),
	    'string': astNode('String'),
	    'time': dimension(TIME),
	    'unicode-range': astNode('UnicodeRange'),
	    'url': url,

	    // old IE stuff
	    'progid': astNode('Raw'),
	    'expression': expression
	};

	var SyntaxParseError = function(message, input, offset) {
	    var error = createCustomError('SyntaxParseError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var error$2 = {
	    SyntaxParseError: SyntaxParseError
	};

	var SyntaxParseError$1 = error$2.SyntaxParseError;

	var TAB$2 = 9;
	var N$3 = 10;
	var F$3 = 12;
	var R$3 = 13;
	var SPACE$2 = 32;

	var Tokenizer$1 = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer$1.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R$3 && code !== N$3 && code !== F$3 && code !== SPACE$2 && code !== TAB$2) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new SyntaxParseError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer$1;

	var TAB$3 = 9;
	var N$4 = 10;
	var F$4 = 12;
	var R$4 = 13;
	var SPACE$3 = 32;
	var EXCLAMATIONMARK$1 = 33;    // !
	var NUMBERSIGN$1 = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE$1 = 39;         // '
	var LEFTPARENTHESIS$1 = 40;    // (
	var RIGHTPARENTHESIS$1 = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$3 = 43;           // +
	var COMMA = 44;              // ,
	var LESSTHANSIGN$1 = 60;       // <
	var GREATERTHANSIGN$1 = 62;    // >
	var QUESTIONMARK = 63;       // ?
	var COMMERCIALAT$1 = 64;       // @
	var LEFTSQUAREBRACKET$1 = 91;  // [
	var RIGHTSQUAREBRACKET$1 = 93; // ]
	var LEFTCURLYBRACKET$1 = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET$1 = 125; // }
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos + 1)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET$1);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET$1) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET$1);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$3:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN$1:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET$1) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET$1:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN$1);
	    tokenizer.eat(APOSTROPHE$1);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE$1);
	    tokenizer.eat(GREATERTHANSIGN$1);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	function readType(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN$1);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS$1 &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS$1) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    tokenizer.eat(GREATERTHANSIGN$1);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS$1) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET$1);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET$1);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK$1) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET$1:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET$1:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN$1:
	            return tokenizer.nextCharCode() === APOSTROPHE$1
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE$1:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$3:
	        case TAB$3:
	        case N$4:
	        case R$4:
	        case F$4:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT$1:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$3:
	        case QUESTIONMARK:
	        case NUMBERSIGN$1:
	        case EXCLAMATIONMARK$1:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET$1:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(str) {
	    var tokenizer = new tokenizer$1(str);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== str.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node, context);
	};

	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = null;
	        var tokens = [];

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                if (tokens.length > 0) {
	                    switch (curNode.type) {
	                        case 'Dimension':
	                        case 'HexColor':
	                        case 'IdSelector':
	                        case 'Percentage':
	                            if (prev.node === curNode) {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;

	                        case 'Function':
	                        case 'PseudoClassSelector':
	                        case 'PseudoElementSelector':
	                        case 'Url':
	                            if (chunk === '(') {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;

	                        case 'Atrule':
	                            if (prev.node === curNode && prev.value === '@') {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;
	                    }
	                }

	                tokens.push(prev = {
	                    value: chunk,
	                    node: curNode
	                });
	            },
	            result: function() {
	                return tokens;
	            }
	        };
	    }
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$2 = 40;  // (
	var RIGHTPARENTHESIS$2 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$2 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$2
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;

	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 10000;
	var totalIterationCount = 0;

	function mapList(list, fn) {
	    var result = [];

	    while (list) {
	        result.unshift(fn(list));
	        list = list.prev;
	    }

	    return result;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    token = token.value.charAt(token.value.length - 1);

	    return (
	        token === ',' ||
	        token === '(' ||
	        token === '[' ||
	        token === '/'
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    token = token.value.charAt(0);

	    return (
	        token === ')' ||
	        token === ']' ||
	        token === '/'
	    );
	}

	function internalMatch(tokens, syntax, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenCursor++;
	            token = tokenCursor < tokens.length ? tokens[tokenCursor] : null;
	        } while (token !== null && !/\S/.test(token.value));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenCursor + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function pushThenStack(nextSyntax) {
	        thenStack = {
	            nextSyntax: nextSyntax,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextSyntax) {
	        elseStack = {
	            nextSyntax: nextSyntax,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenCursor: tokenCursor,
	            token: token,
	            prev: elseStack
	        };
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: syntax.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();

	        if (tokenCursor > longestMatch) {
	            longestMatch = tokenCursor;
	        }

	        return matchStack.token;
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: syntax,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: syntax.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    var iterationCount = 0;
	    var exitReason = EXIT_REASON_MATCH;

	    var matchStack = { type: 'Stub', syntax: null, token: null, tokenCursor: -1, prev: null };
	    var longestMatch = 0;
	    var tokenCursor = -1;
	    var token = null;

	    moveToNextToken();

	    while (true) {
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? x.type + '!' + x.syntax.name : null),
	        //         elseStack: mapList(elseStack, x => x.id),
	        //         thenStack: mapList(thenStack, x => x.id),
	        //         token: token && token.value,
	        //         tokenCursor,
	        //         syntax
	        //     }, { depth: null })
	        // );

	        // prevent infinite loop
	        if (++iterationCount === ITERATION_LIMIT) {
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            break;
	        }

	        if (syntax === MATCH$1) {
	            if (thenStack === null) {
	                // turn to MISMATCH when some tokens left unmatched
	                if (token !== null) {
	                    // doesn't mismatch if just one token left and it's an IE hack
	                    if (tokenCursor !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                        syntax = MISMATCH$1;
	                        continue;
	                    }
	                }

	                // break the main loop, return a result - MATCH
	                exitReason = EXIT_REASON_MATCH;
	                break;
	            }

	            // go to next syntax (`then` branch)
	            syntax = thenStack.nextSyntax;

	            // check match is not empty
	            if (syntax === DISALLOW_EMPTY$1) {
	                if (thenStack.matchStack.token === matchStack.token) {
	                    syntax = MISMATCH$1;
	                    continue;
	                } else {
	                    syntax = MATCH$1;
	                }
	            }

	            // close syntax if needed
	            while (syntaxStack !== null && thenStack.syntaxStack !== syntaxStack) {
	                closeSyntax();
	            }

	            // pop stack
	            thenStack = thenStack.prev;
	            continue;
	        }

	        if (syntax === MISMATCH$1) {
	            if (elseStack === null) {
	                // break the main loop, return a result - MISMATCH
	                exitReason = EXIT_REASON_MISMATCH;
	                break;
	            }

	            // go to next syntax (`else` branch)
	            syntax = elseStack.nextSyntax;

	            // restore all the rest stack states
	            thenStack = elseStack.thenStack;
	            syntaxStack = elseStack.syntaxStack;
	            matchStack = elseStack.matchStack;
	            tokenCursor = elseStack.tokenCursor;
	            token = elseStack.token;

	            // pop stack
	            elseStack = elseStack.prev;
	            continue;
	        }

	        switch (syntax.type) {
	            case 'MatchGraph':
	                syntax = syntax.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (syntax.else !== MISMATCH$1) {
	                    pushElseStack(syntax.else);
	                }

	                if (syntax.then !== MATCH$1) {
	                    pushThenStack(syntax.then);
	                }

	                syntax = syntax.match;
	                break;

	            case 'MatchOnce':
	                syntax = {
	                    type: 'MatchOnceBuffer',
	                    terms: syntax.terms,
	                    all: syntax.all,
	                    matchStack: matchStack,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                if (syntax.index === syntax.terms.length) {
	                    // if no matches during a cycle
	                    if (syntax.matchStack === matchStack) {
	                        // no matches at all or it's required all terms to be matched
	                        if (syntax.mask === 0 || syntax.all) {
	                            syntax = MISMATCH$1;
	                            break;
	                        }

	                        // a partial match is ok
	                        syntax = MATCH$1;
	                        break;
	                    } else {
	                        // start trying to match from the start
	                        syntax.index = 0;
	                        syntax.matchStack = matchStack;
	                    }
	                }

	                for (; syntax.index < syntax.terms.length; syntax.index++) {
	                    if ((syntax.mask & (1 << syntax.index)) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(syntax);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            buffer: syntax
	                        });

	                        // match
	                        syntax = syntax.terms[syntax.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                syntax = syntax.buffer;

	                var newMask = syntax.mask | (1 << (syntax.index - 1));

	                // all terms are matched
	                if (newMask === (1 << syntax.terms.length) - 1) {
	                    syntax = MATCH$1;
	                    continue;
	                }

	                syntax = {
	                    type: 'MatchOnceBuffer',
	                    terms: syntax.terms,
	                    all: syntax.all,
	                    matchStack: syntax.matchStack,
	                    index: syntax.index,
	                    mask: newMask
	                };

	                break;

	            case 'Enum':
	                var name = token !== null ? token.value.toLowerCase() : '';

	                // drop \0 and \9 hack from keyword name
	                if (name.indexOf('\\') !== -1) {
	                    name = name.replace(/\\[09].*$/, '');
	                }

	                if (hasOwnProperty$1.call(syntax.map, name)) {
	                    syntax = syntax.map[name];
	                } else {
	                    syntax = MISMATCH$1;
	                }

	                break;

	            case 'Generic':
	                syntax = syntax.fn(token, addTokenToMatch, getNextToken) ? MATCH$1 : MISMATCH$1;
	                break;

	            case 'Type':
	            case 'Property':
	                openSyntax();

	                var syntaxDict = syntax.type === 'Type' ? 'types' : 'properties';

	                if (hasOwnProperty$1.call(syntaxes, syntaxDict) && syntaxes[syntaxDict][syntax.name]) {
	                    syntax = syntaxes[syntaxDict][syntax.name].match;
	                } else {
	                    syntax = undefined;
	                }

	                if (!syntax) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (syntaxStack.syntax.type === 'Type'
	                            ? '<' + syntaxStack.syntax.name + '>'
	                            : '<\'' + syntaxStack.syntax.name + '\'>')
	                    );
	                }

	                break;

	            case 'Keyword':
	                var name = syntax.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (keywordName.toLowerCase() === name) {
	                        addTokenToMatch();

	                        syntax = MATCH$1;
	                        break;
	                    }
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && token.value.toLowerCase() === syntax.name) {
	                    addTokenToMatch();

	                    syntax = MATCH$1;
	                    break;
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === syntax.value) {
	                    addTokenToMatch();

	                    syntax = MATCH$1;
	                    break;
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.value === ',') {
	                    if (isCommaContextStart(matchStack.token)) {
	                        syntax = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        syntax = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    syntax = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            // case 'String':
	            // TODO: strings with length other than 1 char

	            default:
	                throw new Error('Unknown node type: ' + syntax.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    if (exitReason === EXIT_REASON_MATCH) {
	        while (syntaxStack !== null) {
	            closeSyntax();
	        }
	    } else {
	        matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph$$1, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph$$1, syntaxes || {});

	    if (matchResult.match !== null) {
	        matchResult.match = mapList(matchResult.match, function(item) {
	            if (item.type === OPEN_SYNTAX || item.type === CLOSE_SYNTAX) {
	                return { type: item.type, syntax: item.syntax };
	            }

	            return {
	                syntax: item.syntax,
	                token: item.token && item.token.value,
	                node: item.token && item.token.node
	            };
	        }).slice(1);
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph$$1, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph$$1, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var cursor = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph$$1.syntax || null,
	        match: []
	    };
	    var stack = [host];

	    // revert a list
	    var prev = null;
	    var next = null;
	    while (cursor !== null) {
	        next = cursor.prev;
	        cursor.prev = prev;
	        prev = cursor;
	        cursor = next;
	    }

	    // init the cursor to start with 2nd item since 1st is a stub item
	    cursor = prev.prev;

	    // build a tree
	    while (cursor !== null && cursor.syntax !== null) {
	        var entry = cursor;

	        switch (entry.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: entry.syntax,
	                    match: []
	                });
	                stack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                stack.pop();
	                host = stack[stack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: entry.syntax || null,
	                    token: entry.token.value,
	                    node: entry.token.node
	                });
	        }

	        cursor = cursor.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list$$1) {
	                if (node === start) {
	                    var nodes = new list();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list$$1,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof list;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error$1.SyntaxReferenceError;
	var MatchError$1 = error$1.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords = buildMatchGraph$1(parse_1('inherit | initial | unset'));
	var cssWideKeywordsWithExpression = buildMatchGraph$1(parse_1('inherit | initial | unset | <expression>'));

	function dumpMapSyntax(map, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst ? map[name].syntax : generate_1(map[name].syntax);
	        }
	    }

	    return result;
	}

	function valueHasVar(value) {
	    var hasVar = false;

	    this.syntax.walk(value, function(node) {
	        if (node.type === 'Function' && node.name.toLowerCase() === 'var') {
	            hasVar = true;
	        }
	    });

	    return hasVar;
	}

	function buildMatchResult(match$$1, error, iterations) {
	    return {
	        matched: match$$1,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, node, useCommon) {
	    if (!node) {
	        return buildMatchResult(null, new Error('Node is undefined'));
	    }

	    if (valueHasVar.call(lexer, node)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    var tokens = lexer.syntax.generate(node, astToTokens);
	    var result;

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, lexer, syntax.syntax, node, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure$$1) {
	    this.valueCommonSyntax = cssWideKeywords;
	    this.syntax = syntax;
	    this.generic = false;
	    this.properties = {};
	    this.types = {};
	    this.structure = structure$$1 || getStructureFromConfig(config);

	    if (config) {
	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure$$1 = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure$$1.hasOwnProperty(node.type)) {
	                structure$$1[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic.expression) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (!syntax || !syntax.type) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (!syntax.match) {
	            syntax = this.createDescriptor(syntax);
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var grammar = {
	    SyntaxParseError: error$2.SyntaxParseError,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var TYPE$3 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$3.WhiteSpace;
	var COMMENT$2 = TYPE$3.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var noop$3 = function() {};

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new tokenizer(),
	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new list();
	        },
	        createSingleNodeList: function(node) {
	            return new list().appendData(node);
	        },
	        getFirstListNode: function(list$$1) {
	            return list$$1 && list$$1.first();
	        },
	        getLastListNode: function(list$$1) {
	            return list$$1.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.currentToken;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.scanner.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list$$1) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list$$1);
	                var tail = this.getLastListNode(list$$1);
	                return this.scanner.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.scanner.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.scanner.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        parser.scanner.setSource(source, options.offset, options.line, options.column);
	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.scanner.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return mappingA.name - mappingB.name;
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return mappingA.name - mappingB.name;
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var binarySearch = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;

	/**
	 * Recursive implementation of binary search.
	 *
	 * @param aLow Indices here and lower do not contain the needle.
	 * @param aHigh Indices here and higher do not contain the needle.
	 * @param aNeedle The element being searched for.
	 * @param aHaystack The non-empty array being searched.
	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 */
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	  // This function terminates when one of the following is true:
	  //
	  //   1. We find the exact element we are looking for.
	  //
	  //   2. We did not find the exact element, but we can return the index of
	  //      the next-closest element.
	  //
	  //   3. We did not find the exact element, and there is no next-closest
	  //      element than the one we are searching for, so we return -1.
	  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	  var cmp = aCompare(aNeedle, aHaystack[mid], true);
	  if (cmp === 0) {
	    // Found the element we are looking for.
	    return mid;
	  }
	  else if (cmp > 0) {
	    // Our needle is greater than aHaystack[mid].
	    if (aHigh - mid > 1) {
	      // The element is in the upper half.
	      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // The exact needle element was not found in this haystack. Determine if
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return aHigh < aHaystack.length ? aHigh : -1;
	    } else {
	      return mid;
	    }
	  }
	  else {
	    // Our needle is less than aHaystack[mid].
	    if (mid - aLow > 1) {
	      // The element is in the lower half.
	      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return mid;
	    } else {
	      return aLow < 0 ? -1 : aLow;
	    }
	  }
	}

	/**
	 * This is an implementation of binary search which will always try and return
	 * the index of the closest element if there is no exact hit. This is because
	 * mappings between original and generated line/col pairs are single points,
	 * and there is an implicit region between each of them, so a miss just means
	 * that you aren't on the very start of a region.
	 *
	 * @param aNeedle The element you are looking for.
	 * @param aHaystack The array that is being searched.
	 * @param aCompare A function which takes the needle and an element in the
	 *     array and returns -1, 0, or 1 depending on whether the needle is less
	 *     than, equal to, or greater than the element, respectively.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	 */
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	  if (aHaystack.length === 0) {
	    return -1;
	  }

	  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	  if (index < 0) {
	    return -1;
	  }

	  // We have found either the exact element, or the next-closest element than
	  // the one we are searching for. However, there may be more than one such
	  // element. Make sure we always return the smallest of these.
	  while (index - 1 >= 0) {
	    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	      break;
	    }
	    --index;
	  }

	  return index;
	};
	});
	var binarySearch_1 = binarySearch.GREATEST_LOWER_BOUND;
	var binarySearch_2 = binarySearch.LEAST_UPPER_BOUND;
	var binarySearch_3 = binarySearch.search;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	var quickSort_1 = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};

	var quickSort = {
		quickSort: quickSort_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$2 = arraySet.ArraySet;

	var quickSort$1 = quickSort.quickSort;

	function SourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap)
	    : new BasicSourceMapConsumer(sourceMap);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	};

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      if (source != null && sourceRoot != null) {
	        source = util.join(sourceRoot, source);
	      }
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };

	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: Optional. the column number in the original source.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    if (this.sourceRoot != null) {
	      needle.source = util.relative(this.sourceRoot, needle.source);
	    }
	    if (!this._sources.has(needle.source)) {
	      return [];
	    }
	    needle.source = this._sources.indexOf(needle.source);

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	var SourceMapConsumer_1 = SourceMapConsumer;

	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The only parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet$2.fromArray(names.map(String), true);
	  this._sources = ArraySet$2.fromArray(sources, true);

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort$1(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._sources.toArray().map(function (s) {
	      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	    }, this);
	  }
	});

	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;

	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);

	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64Vlq.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }

	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }

	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }

	          cachedSegments[str] = segment;
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }

	    quickSort$1(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;

	    quickSort$1(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };

	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          if (this.sourceRoot != null) {
	            source = util.join(this.sourceRoot, source);
	          }
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    if (this.sourceRoot != null) {
	      aSource = util.relative(this.sourceRoot, aSource);
	    }

	    if (this._sources.has(aSource)) {
	      return this.sourcesContent[this._sources.indexOf(aSource)];
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + aSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    if (this.sourceRoot != null) {
	      source = util.relative(this.sourceRoot, source);
	    }
	    if (!this._sources.has(source)) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }
	    source = this._sources.indexOf(source);

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The only parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet$2();
	  this._names = new ArraySet$2();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        if (section.consumer.sourceRoot !== null) {
	          source = util.join(section.consumer.sourceRoot, source);
	        }
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = section.consumer._names.at(mapping.name);
	        this._names.add(name);
	        name = this._names.indexOf(name);

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort$1(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort$1(this.__originalMappings, util.compareByOriginalPositions);
	  };

	var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

	var sourceMapConsumer = {
		SourceMapConsumer: SourceMapConsumer_1,
		BasicSourceMapConsumer: BasicSourceMapConsumer_1,
		IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;


	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;

	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;

	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";

	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;

	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;

	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex];
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex];
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });

	    return node;

	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };

	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};

	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};

	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};

	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }

	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator$1(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });

	  return { code: generated.code, map: map };
	};

	var SourceNode_1 = SourceNode;

	var sourceNode = {
		SourceNode: SourceNode_1
	};

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
	var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;
	var SourceNode$1 = sourceNode.SourceNode;

	var sourceMap = {
		SourceMapGenerator: SourceMapGenerator$2,
		SourceMapConsumer: SourceMapConsumer$1,
		SourceNode: SourceNode$1
	};

	var SourceMapGenerator$3 = sourceMap.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap$1 = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$3();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap$1(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof list === false) {
	                        node.children = new list().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof list) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = reverse ? config.fields.slice().reverse() : config.fields;
	    var body = fields.map(function(field) {
	        var ref = 'node.' + field.name;
	        var line;

	        if (field.type === 'list') {
	            line = reverse
	                ? ref + '.forEachRight(walk);'
	                : ref + '.forEach(walk);';
	        } else {
	            line = 'walk(' + ref + ');';
	        }

	        if (field.nullable) {
	            line = 'if (' + ref + ') {\n    ' + line + '}';
	        }

	        return line;
	    });

	    if (config.context) {
	        body = [].concat(
	            'var old = context.' + config.context + ';',
	            'context.' + config.context + ' = node;',
	            body,
	            'context.' + config.context + ' = old;'
	        );
	    }

	    return new Function('node', 'context', 'walk', body.join('\n'));
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    return function walk(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof list) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        var res = {};
	        for (var key in value) {
	            if (hasOwnProperty$5.call(value, key)) {
	                res[key] = value[key];
	            }
	        }
	        return res;
	    } else {
	        return value;
	    }
	}

	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function assign$1(dest, src) {
	    for (var key in src) {
	        dest[key] = src[key];
	    }

	    return dest;
	}

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: list,
	        Tokenizer: tokenizer,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        grammar: grammar,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        parse: parse,
	        walk: walk,
	        generate: generate,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, assign$1)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var appearance = {
		syntax: "auto | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var border = {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	};
	var opacity = {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var quotes = {
		syntax: "none | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var rotate = {
		syntax: "none | [ x | y | z | <number>{3} ]? && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-timing-function": {
		syntax: "<single-timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		appearance: appearance,
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		border: border,
		"border-block-end": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-end-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-bottom": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-inline-end": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-left": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-style": {
		syntax: "<br-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-width": {
		syntax: "<br-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-after": {
		syntax: "auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-before": {
		syntax: "auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		margin: margin,
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-block-end": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-block-start": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-inline-end": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-inline-start": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angle",
		percentages: "no",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-style": {
		syntax: "auto | <br-style>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-width": {
		syntax: "<br-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "<'overflow'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overflow-inline": {
		syntax: "<'overflow'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		padding: padding,
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		scale: scale,
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"scroll-snap-type": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"shape-image-threshold": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-timing-function": {
		syntax: "<single-transition-timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		default: properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"br-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"br-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color> <length-percentage>?"
	},
		"color-stop-list": {
		syntax: "<color-stop>#{2,}"
	},
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | subgrid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> {\n  <feature-value-declaration-list>\n}"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frames-timing-function": {
		syntax: "frames(<integer>)"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( [ [ <image> | <string> ]? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <border-radius> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number> [, <number> ]{5,5} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number> [, <number> ]{15,15} )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> {\n  <declaration-list>\n}"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( <angle> )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , <angle> )"
	},
		"rotateX()": {
		syntax: "rotateX( <angle> )"
	},
		"rotateY()": {
		syntax: "rotateY( <angle> )"
	},
		"rotateZ()": {
		syntax: "rotateZ( <angle> )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> [, <number> ]? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( <angle> [, <angle> ]? )"
	},
		"skewX()": {
		syntax: "skewX( <angle> )"
	},
		"skewY()": {
		syntax: "skewY( <angle> )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function> | <frames-timing-function>"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <single-transition-timing-function> || <time>"
	},
		"single-transition-timing-function": {
		syntax: "<single-timing-function>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, [ start | end ] ]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> [, <length-percentage> ]? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | integer | color | url | integer | number | length | angle | time | frequency | em | ex | px | rem | vw | vh | vmin | vmax | mm | q | cm | in | pt | pc | deg | grad | rad | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> [, <declaration-value> ]? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		attachment: attachment,
		box: box,
		color: color$1,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		default: syntaxes
	});

	var properties$3 = {
		"--*": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-line-clamp": {
			comment: "non-standard and deprecated but may still using by some sites",
			syntax: "<positive-integer>"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-mask-clip": {
			comment: "change type to <-webkit-mask-clip-style> since it differ from <mask-clip>, extra space between [ and ,",
			syntax: "<-webkit-mask-clip-style> [, <-webkit-mask-clip-style> ]*"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			refenrences: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "none | inline | block | list-item | inline-list-item | inline-block | inline-table | table | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | flex | inline-flex | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter>"
		},
		font: {
			comment: "extend with non-standard fonts",
			syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar | <-non-standard-font>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		"line-height-step": {
			comment: "fix extra spaces around",
			syntax: "none | <length>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "visible | hidden | scroll | auto | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"transform-origin": {
			comment: "move first group to the end since less collecting",
			syntax: "[ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>? | [ <length-percentage> | left | center | right | top | bottom ]"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<unicode-range>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"word-break": {
			comment: "extend with non-standard keywords",
			syntax: "normal | break-all | keep-all | <-non-standard-word-break>"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to duoble sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			preferences: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-non-standard-word-break": {
			comment: "non-standard keywords https://css-tricks.com/almanac/properties/w/word-break/",
			syntax: "break-word"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter": {
			syntax: "[ <progid> | FlipH | FlipV ]+"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr()": {
			comment: "drop it since it's a generic",
			syntax: null
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"inset()": {
			comment: "changed <border-radius> to <'border-radius'>",
			syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added -webkit-gradient() since may to be used for legacy support",
			syntax: "<-legacy-gradient> | <linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"matrix()": {
			comment: "redundant max",
			syntax: "matrix( <number> [, <number> ]{5} )"
		},
		"matrix3d()": {
			comment: "redundant max",
			syntax: "matrix3d( <number> [, <number> ]{15} )"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "replaced <ident> to list of colors according to https://www.w3.org/TR/css-color-4/#named-colors",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		"outline-radius": {
			comment: "missed, looks like it's a similar to <border-radius> https://developer.mozilla.org/en/docs/Web/CSS/-moz-outline-radius",
			syntax: "<border-radius>"
		},
		paint: {
			comment: "simplified SVG syntax (omit <icccolor>, replace <funciri> for <url>) https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | currentColor | <color> | <url> [ none | currentColor | <color> ]?"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( [ [ <top>, <right>, <bottom>, <left> ] | [ <top> <right> <bottom> <left> ] ] )"
		},
		"single-transition": {
			comment: "moved <single-transition-timing-function> in the beginning to avoid wrong match to <single-transition-property>",
			syntax: "<single-transition-timing-function> || [ none | <single-transition-property> ] || <time> || <time>"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		"var()": {
			comment: "drop it since it's a generic (also syntax is incorrect and can't be parsed)",
			syntax: null
		},
		"an-plus-b": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-type": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-block": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-declaration": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-block-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-declaration-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"general-enclosed": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"keyframe-block": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"keyframe-block-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-plain": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-range": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-value": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-and": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-condition": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-not": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-or": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-in-parens": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-feature": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-condition-without-or": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-query": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-query-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		nth: {
			comment: "syntax has <an-plus-b> that doesn't support currently, drop for now",
			syntax: null
		},
		"page-selector": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-selector-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-body": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-margin-box": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-margin-box-type": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"pseudo-page": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		properties: properties$3,
		syntaxes: syntaxes$2,
		default: patch
	});

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    properties: buildDictionary(mdnProperties, patch$2.properties),
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes)
	};

	var cmpChar$1 = tokenizer.cmpChar;
	var isNumber$3 = tokenizer.isNumber;
	var TYPE$4 = tokenizer.TYPE;

	var IDENTIFIER$3 = TYPE$4.Identifier;
	var NUMBER$2 = TYPE$4.Number;
	var PLUSSIGN$4 = TYPE$4.PlusSign;
	var HYPHENMINUS$4 = TYPE$4.HyphenMinus;
	var N$5 = 110; // 'n'.charCodeAt(0)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function checkTokenIsInteger(scanner, disallowSign) {
	    var pos = scanner.tokenStart;

	    if (scanner.source.charCodeAt(pos) === PLUSSIGN$4 ||
	        scanner.source.charCodeAt(pos) === HYPHENMINUS$4) {
	        if (disallowSign) {
	            scanner.error();
	        }
	        pos++;
	    }

	    for (; pos < scanner.tokenEnd; pos++) {
	        if (!isNumber$3(scanner.source.charCodeAt(pos))) {
	            scanner.error('Unexpected input', pos);
	        }
	    }
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = start;
	        var prefix = '';
	        var a = null;
	        var b = null;

	        if (this.scanner.tokenType === NUMBER$2 ||
	            this.scanner.tokenType === PLUSSIGN$4) {
	            checkTokenIsInteger(this.scanner, ALLOW_SIGN);
	            prefix = this.scanner.getTokenValue();
	            this.scanner.next();
	            end = this.scanner.tokenStart;
	        }

	        if (this.scanner.tokenType === IDENTIFIER$3) {
	            var bStart = this.scanner.tokenStart;

	            if (cmpChar$1(this.scanner.source, bStart, HYPHENMINUS$4)) {
	                if (prefix === '') {
	                    prefix = '-';
	                    bStart++;
	                } else {
	                    this.scanner.error('Unexpected hyphen minus');
	                }
	            }

	            if (!cmpChar$1(this.scanner.source, bStart, N$5)) {
	                this.scanner.error();
	            }

	            a = prefix === ''  ? '1'  :
	                prefix === '+' ? '+1' :
	                prefix === '-' ? '-1' :
	                prefix;

	            var len = this.scanner.tokenEnd - bStart;
	            if (len > 1) {
	                // ..n-..
	                if (this.scanner.source.charCodeAt(bStart + 1) !== HYPHENMINUS$4) {
	                    this.scanner.error('Unexpected input', bStart + 1);
	                }

	                if (len > 2) {
	                    // ..n-{number}..
	                    this.scanner.tokenStart = bStart + 2;
	                } else {
	                    // ..n- {number}
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                }

	                checkTokenIsInteger(this.scanner, DISALLOW_SIGN);
	                b = '-' + this.scanner.getTokenValue();
	                this.scanner.next();
	                end = this.scanner.tokenStart;
	            } else {
	                prefix = '';
	                this.scanner.next();
	                end = this.scanner.tokenStart;
	                this.scanner.skipSC();

	                if (this.scanner.tokenType === HYPHENMINUS$4 ||
	                    this.scanner.tokenType === PLUSSIGN$4) {
	                    prefix = this.scanner.getTokenValue();
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                }

	                if (this.scanner.tokenType === NUMBER$2) {
	                    checkTokenIsInteger(this.scanner, prefix !== '');

	                    if (!isNumber$3(this.scanner.source.charCodeAt(this.scanner.tokenStart))) {
	                        prefix = this.scanner.source.charAt(this.scanner.tokenStart);
	                        this.scanner.tokenStart++;
	                    }

	                    if (prefix === '') {
	                        // should be an operator before number
	                        this.scanner.error();
	                    } else if (prefix === '+') {
	                        // plus is using by default
	                        prefix = '';
	                    }

	                    b = prefix + this.scanner.getTokenValue();

	                    this.scanner.next();
	                    end = this.scanner.tokenStart;
	                } else {
	                    if (prefix) {
	                        this.scanner.eat(NUMBER$2);
	                    }
	                }
	            }
	        } else {
	            if (prefix === '' || prefix === '+') { // no number
	                this.scanner.error(
	                    'Number or identifier is expected',
	                    this.scanner.tokenStart + (
	                        this.scanner.tokenType === PLUSSIGN$4 ||
	                        this.scanner.tokenType === HYPHENMINUS$4
	                    )
	                );
	            }

	            b = prefix;
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, end),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' :
	                node.a ===  '1' ?  'n' :
	                node.a === '-1' ? '-n' :
	                node.a + 'n'
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$5 = tokenizer.TYPE;

	var ATKEYWORD$2 = TYPE$5.AtKeyword;
	var SEMICOLON = TYPE$5.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$5.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$5.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, SEMICOLON, LEFTCURLYBRACKET$2, false, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$2) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$2 ||
	            type === ATKEYWORD$2) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.scanner.eat(ATKEYWORD$2);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.currentToken);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$2:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$6 = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$6.Semicolon;
	var LEFTCURLYBRACKET$3 = TYPE$6.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$3 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.scanner.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$7 = tokenizer.TYPE;

	var IDENTIFIER$4 = TYPE$7.Identifier;
	var STRING$2 = TYPE$7.String;
	var DOLLARSIGN = TYPE$7.DollarSign;
	var ASTERISK$1 = TYPE$7.Asterisk;
	var COLON = TYPE$7.Colon;
	var EQUALSSIGN = TYPE$7.EqualsSign;
	var LEFTSQUAREBRACKET$2 = TYPE$7.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$7.RightSquareBracket;
	var CIRCUMFLEXACCENT = TYPE$7.CircumflexAccent;
	var VERTICALLINE$1 = TYPE$7.VerticalLine;
	var TILDE = TYPE$7.Tilde;

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.scanner.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdentifier = false;
	    var checkColon = true;

	    if (this.scanner.tokenType === ASTERISK$1) {
	        expectIdentifier = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (this.scanner.tokenType !== VERTICALLINE$1) {
	        this.scanner.eat(IDENTIFIER$4);
	    }

	    if (this.scanner.tokenType === VERTICALLINE$1) {
	        if (this.scanner.lookupType(1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.scanner.eat(IDENTIFIER$4);
	        } else if (expectIdentifier) {
	            this.scanner.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdentifier) {
	        this.scanner.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.scanner.eat(IDENTIFIER$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var tokenType = this.scanner.tokenType;

	    if (tokenType !== EQUALSSIGN &&        // =
	        tokenType !== TILDE &&             // ~=
	        tokenType !== CIRCUMFLEXACCENT &&  // ^=
	        tokenType !== DOLLARSIGN &&        // $=
	        tokenType !== ASTERISK$1 &&          // *=
	        tokenType !== VERTICALLINE$1         // |=
	    ) {
	        this.scanner.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    if (tokenType === EQUALSSIGN) {
	        this.scanner.next();
	    } else {
	        this.scanner.next();
	        this.scanner.eat(EQUALSSIGN);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' S* attrib_name ']'
	// '[' S* attrib_name S* attrib_matcher S* [ IDENT | STRING ] S* attrib_flags? S* ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.scanner.eat(LEFTSQUAREBRACKET$2);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$2) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENTIFIER$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING$2
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENTIFIER$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.scanner.eat(RIGHTSQUAREBRACKET$2);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$8 = tokenizer.TYPE;

	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var COMMENT$3 = TYPE$8.Comment;
	var SEMICOLON$2 = TYPE$8.Semicolon;
	var ATKEYWORD$3 = TYPE$8.AtKeyword;
	var LEFTCURLYBRACKET$4 = TYPE$8.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$3 = TYPE$8.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, 0, 0, false, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, 0, SEMICOLON$2, true, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.currentToken);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.scanner.eat(LEFTCURLYBRACKET$4);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$3:
	                    break scan;

	                case WHITESPACE$3:
	                case COMMENT$3:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$3:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTCURLYBRACKET$3);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$9 = tokenizer.TYPE;
	var LEFTSQUAREBRACKET$3 = TYPE$9.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$3 = TYPE$9.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.scanner.eat(LEFTSQUAREBRACKET$3);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTSQUAREBRACKET$3);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC$2 = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(CDC$2); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO$2 = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(CDO$2); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$a = tokenizer.TYPE;
	var IDENTIFIER$5 = TYPE$a.Identifier;
	var FULLSTOP$2 = TYPE$a.FullStop;

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        this.scanner.eat(FULLSTOP$2);

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$b = tokenizer.TYPE;

	var PLUSSIGN$5 = TYPE$b.PlusSign;
	var SOLIDUS = TYPE$b.Solidus;
	var GREATERTHANSIGN$2 = TYPE$b.GreaterThanSign;
	var TILDE$1 = TYPE$b.Tilde;

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        switch (this.scanner.tokenType) {
	            case GREATERTHANSIGN$2:
	            case PLUSSIGN$5:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();
	                this.scanner.expectIdentifier('deep');
	                this.scanner.eat(SOLIDUS);
	                break;

	            default:
	                this.scanner.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$c = tokenizer.TYPE;

	var ASTERISK$2 = TYPE$c.Asterisk;
	var SOLIDUS$1 = TYPE$c.Solidus;

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        this.scanner.next();

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$d = tokenizer.TYPE;

	var IDENTIFIER$6 = TYPE$d.Identifier;
	var COLON$1 = TYPE$d.Colon;
	var EXCLAMATIONMARK$2 = TYPE$d.ExclamationMark;
	var SOLIDUS$2 = TYPE$d.Solidus;
	var ASTERISK$3 = TYPE$d.Asterisk;
	var DOLLARSIGN$1 = TYPE$d.DollarSign;
	var HYPHENMINUS$5 = TYPE$d.HyphenMinus;
	var SEMICOLON$3 = TYPE$d.Semicolon;
	var PLUSSIGN$6 = TYPE$d.PlusSign;
	var NUMBERSIGN$2 = TYPE$d.NumberSign;

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, EXCLAMATIONMARK$2, SEMICOLON$3, false, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, EXCLAMATIONMARK$2, SEMICOLON$3, false, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.currentToken;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.tokenType !== EXCLAMATIONMARK$2 &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.scanner.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.currentToken;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.scanner.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.currentToken);
	        }

	        if (this.scanner.tokenType === EXCLAMATIONMARK$2) {
	            important = getImportant(this.scanner);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.scanner.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;
	    var prefix = 0;

	    // hacks
	    switch (this.scanner.tokenType) {
	        case ASTERISK$3:
	        case DOLLARSIGN$1:
	        case PLUSSIGN$6:
	        case NUMBERSIGN$2:
	            prefix = 1;
	            break;

	        // TODO: not sure we should support this hack
	        case SOLIDUS$2:
	            prefix = this.scanner.lookupType(1) === SOLIDUS$2 ? 2 : 1;
	            break;
	    }

	    if (this.scanner.lookupType(prefix) === HYPHENMINUS$5) {
	        prefix++;
	    }

	    if (prefix) {
	        this.scanner.skip(prefix);
	    }

	    this.scanner.eat(IDENTIFIER$6);

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant(scanner) {
	    scanner.eat(EXCLAMATIONMARK$2);
	    scanner.skipSC();

	    var important = scanner.consume(IDENTIFIER$6);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$e = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$4 = TYPE$e.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, 0, SEMICOLON$4, true, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$4:
	                case COMMENT$4:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var NUMBER$3 = tokenizer.TYPE.Number;

	// special reader for units to avoid adjoined IE hacks (i.e. '1px\9')
	function readUnit(scanner) {
	    var unit = scanner.getTokenValue();
	    var backSlashPos = unit.indexOf('\\');

	    if (backSlashPos > 0) {
	        // patch token offset
	        scanner.tokenStart += backSlashPos;

	        // return part before backslash
	        return unit.substring(0, backSlashPos);
	    }

	    // no backslash in unit name
	    scanner.next();

	    return unit;
	}

	// number ident
	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value = this.scanner.consume(NUMBER$3);
	        var unit = readUnit(this.scanner);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value,
	            unit: unit
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$f = tokenizer.TYPE;
	var RIGHTPARENTHESIS$3 = TYPE$f.RightParenthesis;

	// <function-token> <sequence> ')'
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.scanner.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTPARENTHESIS$3);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var isHex$2 = tokenizer.isHex;
	var TYPE$g = tokenizer.TYPE;

	var IDENTIFIER$7 = TYPE$g.Identifier;
	var NUMBER$4 = TYPE$g.Number;
	var NUMBERSIGN$3 = TYPE$g.NumberSign;

	function consumeHexSequence(scanner, required) {
	    if (!isHex$2(scanner.source.charCodeAt(scanner.tokenStart))) {
	        if (required) {
	            scanner.error('Unexpected input', scanner.tokenStart);
	        } else {
	            return;
	        }
	    }

	    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
	        var code = scanner.source.charCodeAt(pos);

	        // break on non-hex char
	        if (!isHex$2(code)) {
	            // break token, exclude symbol
	            scanner.tokenStart = pos;
	            return;
	        }
	    }

	    // token is full hex sequence, go to next token
	    scanner.next();
	}

	// # ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(NUMBERSIGN$3);

	        scan:
	        switch (this.scanner.tokenType) {
	            case NUMBER$4:
	                consumeHexSequence(this.scanner, true);

	                // if token is identifier then number consists of hex only,
	                // try to add identifier to result
	                if (this.scanner.tokenType === IDENTIFIER$7) {
	                    consumeHexSequence(this.scanner, false);
	                }

	                break;

	            case IDENTIFIER$7:
	                consumeHexSequence(this.scanner, true);
	                break;

	            default:
	                this.scanner.error('Number or identifier is expected');
	        }

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1) // skip #
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$h = tokenizer.TYPE;
	var IDENTIFIER$8 = TYPE$h.Identifier;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;
	var IDENTIFIER$9 = TYPE$i.Identifier;
	var NUMBERSIGN$4 = TYPE$i.NumberSign;

	// '#' ident
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        this.scanner.eat(NUMBERSIGN$4);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$9)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$j = tokenizer.TYPE;

	var IDENTIFIER$a = TYPE$j.Identifier;
	var NUMBER$5 = TYPE$j.Number;
	var LEFTPARENTHESIS$3 = TYPE$j.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$j.RightParenthesis;
	var COLON$2 = TYPE$j.Colon;
	var SOLIDUS$3 = TYPE$j.Solidus;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.scanner.eat(LEFTPARENTHESIS$3);
	        this.scanner.skipSC();

	        name = this.scanner.consume(IDENTIFIER$a);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$4) {
	            this.scanner.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$5:
	                    if (this.scanner.lookupType(1) === IDENTIFIER$a) {
	                        value = this.Dimension();
	                    } else if (this.scanner.lookupNonWSType(1) === SOLIDUS$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case IDENTIFIER$a:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.scanner.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.scanner.eat(RIGHTPARENTHESIS$4);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$k = tokenizer.TYPE;

	var WHITESPACE$5 = TYPE$k.WhiteSpace;
	var COMMENT$5 = TYPE$k.Comment;
	var IDENTIFIER$b = TYPE$k.Identifier;
	var LEFTPARENTHESIS$4 = TYPE$k.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$5:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$5:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENTIFIER$b:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$4:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.scanner.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	// https://drafts.csswg.org/css-syntax-3/#the-anb-type
	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$6 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.scanner.consume(NUMBER$6)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$l = tokenizer.TYPE;
	var LEFTPARENTHESIS$5 = TYPE$l.LeftParenthesis;
	var RIGHTPARENTHESIS$5 = TYPE$l.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.scanner.eat(LEFTPARENTHESIS$5);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTPARENTHESIS$5);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var NUMBER$7 = TYPE$m.Number;
	var PERCENTSIGN = TYPE$m.PercentSign;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var number = this.scanner.consume(NUMBER$7);

	        this.scanner.eat(PERCENTSIGN);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: number
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$n = tokenizer.TYPE;

	var IDENTIFIER$c = TYPE$n.Identifier;
	var FUNCTION$2 = TYPE$n.Function;
	var COLON$3 = TYPE$n.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$n.RightParenthesis;

	// : ident [ '(' .. ')' ]?
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.scanner.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.scanner.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
	                );
	            }

	            this.scanner.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.scanner.consume(IDENTIFIER$c);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENTIFIER$d = TYPE$o.Identifier;
	var FUNCTION$3 = TYPE$o.Function;
	var COLON$4 = TYPE$o.Colon;
	var RIGHTPARENTHESIS$7 = TYPE$o.RightParenthesis;

	// :: ident [ '(' .. ')' ]?
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.scanner.eat(COLON$4);
	        this.scanner.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$3) {
	            name = this.scanner.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
	                );
	            }

	            this.scanner.eat(RIGHTPARENTHESIS$7);
	        } else {
	            name = this.scanner.consume(IDENTIFIER$d);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isNumber$4 = tokenizer.isNumber;
	var TYPE$p = tokenizer.TYPE;
	var NUMBER$8 = TYPE$p.Number;
	var SOLIDUS$4 = TYPE$p.Solidus;
	var FULLSTOP$3 = TYPE$p.FullStop;

	// Terms of <ratio> should to be a positive number (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without exponent part.
	// Additional checks may to be applied on lexer validation.
	function consumeNumber$1(scanner) {
	    var value = scanner.consumeNonWS(NUMBER$8);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isNumber$4(code) && code !== FULLSTOP$3) {
	            scanner.error('Unsigned number is expected', scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        scanner.error('Zero number is not allowed', scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$1(this.scanner);
	        var right;

	        this.scanner.eatNonWS(SOLIDUS$4);
	        right = consumeNumber$1(this.scanner);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, endTokenType1, endTokenType2, includeTokenType2, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(
	                startToken,
	                endTokenType1,
	                endTokenType2,
	                includeTokenType2
	            )
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = this.scanner.getOffsetExcludeWS();
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var LEFTCURLYBRACKET$5 = TYPE$q.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, LEFTCURLYBRACKET$5, 0, false, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$5) {
	        this.scanner.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.currentToken;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.scanner.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var COMMA$2 = TYPE$r.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$3 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.scanner.consume(STRING$3)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var WHITESPACE$6 = TYPE$s.WhiteSpace;
	var COMMENT$6 = TYPE$s.Comment;
	var EXCLAMATIONMARK$3 = TYPE$s.ExclamationMark;
	var ATKEYWORD$4 = TYPE$s.AtKeyword;
	var CDO$3 = TYPE$s.CDO;
	var CDC$3 = TYPE$s.CDC;

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, 0, 0, false, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$6:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$3: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$3: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$4:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$t = tokenizer.TYPE;

	var IDENTIFIER$e = TYPE$t.Identifier;
	var ASTERISK$4 = TYPE$t.Asterisk;
	var VERTICALLINE$2 = TYPE$t.VerticalLine;

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENTIFIER$e &&
	        this.scanner.tokenType !== ASTERISK$4) {
	        this.scanner.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.tokenType === VERTICALLINE$2) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.tokenType === VERTICALLINE$2) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHex$3 = tokenizer.isHex;
	var TYPE$u = tokenizer.TYPE;

	var IDENTIFIER$f = TYPE$u.Identifier;
	var NUMBER$9 = TYPE$u.Number;
	var PLUSSIGN$7 = TYPE$u.PlusSign;
	var HYPHENMINUS$6 = TYPE$u.HyphenMinus;
	var FULLSTOP$4 = TYPE$u.FullStop;
	var QUESTIONMARK$1 = TYPE$u.QuestionMark;

	function scanUnicodeNumber(scanner) {
	    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
	        var code = scanner.source.charCodeAt(pos);

	        // break on fullstop or hyperminus/plussign after exponent
	        if (code === FULLSTOP$4 || code === PLUSSIGN$7) {
	            // break token, exclude symbol
	            scanner.tokenStart = pos;
	            return false;
	        }
	    }

	    return true;
	}

	// https://drafts.csswg.org/css-syntax-3/#urange
	function scanUnicodeRange(scanner) {
	    var hexStart = scanner.tokenStart + 1; // skip +
	    var hexLength = 0;

	    scan: {
	        if (scanner.tokenType === NUMBER$9) {
	            if (scanner.source.charCodeAt(scanner.tokenStart) !== FULLSTOP$4 && scanUnicodeNumber(scanner)) {
	                scanner.next();
	            } else if (scanner.source.charCodeAt(scanner.tokenStart) !== HYPHENMINUS$6) {
	                break scan;
	            }
	        } else {
	            scanner.next(); // PLUSSIGN
	        }

	        if (scanner.tokenType === HYPHENMINUS$6) {
	            scanner.next();
	        }

	        if (scanner.tokenType === NUMBER$9) {
	            scanner.next();
	        }

	        if (scanner.tokenType === IDENTIFIER$f) {
	            scanner.next();
	        }

	        if (scanner.tokenStart === hexStart) {
	            scanner.error('Unexpected input', hexStart);
	        }
	    }

	    // validate for U+x{1,6} or U+x{1,6}-x{1,6}
	    // where x is [0-9a-fA-F]
	    for (var i = hexStart, wasHyphenMinus = false; i < scanner.tokenStart; i++) {
	        var code = scanner.source.charCodeAt(i);

	        if (isHex$3(code) === false && (code !== HYPHENMINUS$6 || wasHyphenMinus)) {
	            scanner.error('Unexpected input', i);
	        }

	        if (code === HYPHENMINUS$6) {
	            // hex sequence shouldn't be an empty
	            if (hexLength === 0) {
	                scanner.error('Unexpected input', i);
	            }

	            wasHyphenMinus = true;
	            hexLength = 0;
	        } else {
	            hexLength++;

	            // too long hex sequence
	            if (hexLength > 6) {
	                scanner.error('Too long hex sequence', i);
	            }
	        }

	    }

	    // check we have a non-zero sequence
	    if (hexLength === 0) {
	        scanner.error('Unexpected input', i - 1);
	    }

	    // U+abc???
	    if (!wasHyphenMinus) {
	        // consume as many U+003F QUESTION MARK (?) code points as possible
	        for (; hexLength < 6 && !scanner.eof; scanner.next()) {
	            if (scanner.tokenType !== QUESTIONMARK$1) {
	                break;
	            }

	            hexLength++;
	        }
	    }
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next(); // U or u
	        scanUnicodeRange(this.scanner);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$v = tokenizer.TYPE;

	var STRING$4 = TYPE$v.String;
	var URL$3 = TYPE$v.Url;
	var RAW$2 = TYPE$v.Raw;
	var RIGHTPARENTHESIS$8 = TYPE$v.RightParenthesis;

	// url '(' S* (string | raw) S* ')'
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        this.scanner.eat(URL$3);
	        this.scanner.skipSC();

	        switch (this.scanner.tokenType) {
	            case STRING$4:
	                value = this.String();
	                break;

	            case RAW$2:
	                value = this.Raw(this.scanner.currentToken, 0, RAW$2, true, false);
	                break;

	            default:
	                this.scanner.error('String or Raw is expected');
	        }

	        this.scanner.skipSC();
	        this.scanner.eat(RIGHTPARENTHESIS$8);

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$7 = tokenizer.TYPE.WhiteSpace;
	var SPACE$4 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.scanner.eat(WHITESPACE$7);
	        return SPACE$4;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.scanner.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$w = tokenizer.TYPE;

	var IDENTIFIER$g = TYPE$w.Identifier;
	var STRING$5 = TYPE$w.String;
	var NUMBER$a = TYPE$w.Number;
	var FUNCTION$4 = TYPE$w.Function;
	var URL$4 = TYPE$w.Url;
	var NUMBERSIGN$5 = TYPE$w.NumberSign;
	var LEFTPARENTHESIS$6 = TYPE$w.LeftParenthesis;
	var LEFTSQUAREBRACKET$4 = TYPE$w.LeftSquareBracket;
	var PLUSSIGN$8 = TYPE$w.PlusSign;
	var HYPHENMINUS$7 = TYPE$w.HyphenMinus;
	var COMMA$3 = TYPE$w.Comma;
	var SOLIDUS$5 = TYPE$w.Solidus;
	var ASTERISK$5 = TYPE$w.Asterisk;
	var PERCENTSIGN$1 = TYPE$w.PercentSign;
	var BACKSLASH = TYPE$w.Backslash;
	var U = 117; // 'u'.charCodeAt(0)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case NUMBERSIGN$5:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case SOLIDUS$5:
	        case ASTERISK$5:
	        case PLUSSIGN$8:
	        case HYPHENMINUS$7:
	            return this.Operator();

	        case LEFTPARENTHESIS$6:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$4:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$5:
	            return this.String();

	        case NUMBER$a:
	            switch (this.scanner.lookupType(1)) {
	                case PERCENTSIGN$1:
	                    return this.Percentage();

	                case IDENTIFIER$g:
	                    // edge case: number with folowing \0 and \9 hack shouldn't to be a Dimension
	                    if (cmpChar$2(this.scanner.source, this.scanner.tokenEnd, BACKSLASH)) {
	                        return this.Number();
	                    } else {
	                        return this.Dimension();
	                    }

	                default:
	                    return this.Number();
	            }

	        case FUNCTION$4:
	            return this.Function(this.readSequence, context.recognizer);

	        case URL$4:
	            return this.Url();

	        case IDENTIFIER$g:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$2(this.scanner.source, this.scanner.tokenStart, U) &&
	                cmpChar$2(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$8)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$x = tokenizer.TYPE;

	var IDENTIFIER$h = TYPE$x.Identifier;
	var NUMBER$b = TYPE$x.Number;
	var NUMBERSIGN$6 = TYPE$x.NumberSign;
	var LEFTSQUAREBRACKET$5 = TYPE$x.LeftSquareBracket;
	var PLUSSIGN$9 = TYPE$x.PlusSign;
	var SOLIDUS$6 = TYPE$x.Solidus;
	var ASTERISK$6 = TYPE$x.Asterisk;
	var FULLSTOP$5 = TYPE$x.FullStop;
	var COLON$5 = TYPE$x.Colon;
	var GREATERTHANSIGN$3 = TYPE$x.GreaterThanSign;
	var VERTICALLINE$3 = TYPE$x.VerticalLine;
	var TILDE$2 = TYPE$x.Tilde;

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case PLUSSIGN$9:
	        case GREATERTHANSIGN$3:
	        case TILDE$2:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Combinator();

	        case SOLIDUS$6:  // /deep/
	            return this.Combinator();

	        case FULLSTOP$5:
	            return this.ClassSelector();

	        case LEFTSQUAREBRACKET$5:
	            return this.AttributeSelector();

	        case NUMBERSIGN$6:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENTIFIER$h:
	        case ASTERISK$6:
	        case VERTICALLINE$3:
	            return this.TypeSelector();

	        case NUMBER$b:
	            return this.Percentage();
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression '(' raw ')'
	var expression$1 = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.currentToken, 0, 0, false, false)
	    );
	};

	var TYPE$y = tokenizer.TYPE;

	var IDENTIFIER$i = TYPE$y.Identifier;
	var COMMA$4 = TYPE$y.Comma;
	var SEMICOLON$5 = TYPE$y.Semicolon;
	var HYPHENMINUS$8 = TYPE$y.HyphenMinus;
	var EXCLAMATIONMARK$4 = TYPE$y.ExclamationMark;

	// var '(' ident (',' <value>? )? ')'
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    var identStart = this.scanner.tokenStart;

	    this.scanner.eat(HYPHENMINUS$8);
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== HYPHENMINUS$8) {
	        this.scanner.error('HyphenMinus is expected');
	    }
	    this.scanner.eat(IDENTIFIER$i);

	    children.push({
	        type: 'Identifier',
	        loc: this.getLocation(identStart, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(identStart)
	    });

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.currentToken, EXCLAMATIONMARK$4, SEMICOLON$5, false, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression$1,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var STRING$6 = TYPE$z.String;
	var IDENTIFIER$j = TYPE$z.Identifier;
	var URL$5 = TYPE$z.Url;
	var LEFTPARENTHESIS$7 = TYPE$z.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$6:
	                    children.push(this.String());
	                    break;

	                case URL$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.scanner.error('String or url() is expected');
	            }

	            if (this.scanner.lookupNonWSType(0) === IDENTIFIER$j ||
	                this.scanner.lookupNonWSType(0) === LEFTPARENTHESIS$7) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$A = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$A.WhiteSpace;
	var COMMENT$7 = TYPE$A.Comment;
	var IDENTIFIER$k = TYPE$A.Identifier;
	var FUNCTION$5 = TYPE$A.Function;
	var LEFTPARENTHESIS$8 = TYPE$A.LeftParenthesis;
	var HYPHENMINUS$9 = TYPE$A.HyphenMinus;
	var COLON$6 = TYPE$A.Colon;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.currentToken, 0, 0, false, false)
	    );
	}

	function parentheses() {
	    var index = 0;

	    this.scanner.skipSC();

	    // TODO: make it simplier
	    if (this.scanner.tokenType === IDENTIFIER$k) {
	        index = 1;
	    } else if (this.scanner.tokenType === HYPHENMINUS$9 &&
	               this.scanner.lookupType(1) === IDENTIFIER$k) {
	        index = 2;
	    }

	    if (index !== 0 && this.scanner.lookupNonWSType(index) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$8:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$7:
	                this.scanner.next();
	                continue;

	            case FUNCTION$5:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENTIFIER$k:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$8:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.scanner.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}

		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let href = node.value.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					node.value.value = url.toString();
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-bleed-top: 0;
	--pagedjs-bleed-right: 0;
	--pagedjs-bleed-bottom: 0;
	--pagedjs-bleed-left: 0;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}


.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

img {
	height: auto;
}

@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: var(--pagedjs-width);
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || 'get', url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials=='include';

			request.onload = () => {
	 			// Chrome returns a status code of 0 for local files
	 			const status = request.status === 0 && url.startsWith('file://') ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "mm"
			},
			height: {
				value: 14,
				unit: "mm"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "mm"
			},
			height: {
				value: 17,
				unit: "mm"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;

			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin : {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclartations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;


				if ((width && height) &&
						(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed);

					this.emit("size", { width, height, orientation, format, bleed });
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclartations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);
					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);
					} else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									default:
										// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;
		}

		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let {value, unit} = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					margins.push(node);
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages && !pages["*"].added) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
				pages["*"].added = true;
			}
			// Add :left & :right
			if (":left" in pages && !pages[":left"].added) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
				pages[":left"].added = true;
			}
			if (":right" in pages && !pages[":right"].added) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
				pages[":right"].added = true;
			}
			// Add :first & :blank
			if (":first" in pages && !pages[":first"].first) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
				pages[":first"].added = true;
			}
			if (":blank" in pages && !pages[":blank"].added) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
				pages[":blank"].added = true;
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth && !pages[pg].added) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
					pages[pg].added = true;
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name && !pages[pg].added) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
					pages[pg].added = true;
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};
			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());

			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}

			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);
				}
			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent$$1 = false;

				if(block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent$$1 = false;
							} else {
								hasContent$$1 = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
							 loc === "top-center" ||
							 loc === "top-right" ||
							 loc === "bottom-left" ||
							 loc === "bottom-center" ||
							 loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
							 loc === "left-middle" ||
							 loc === "left-bottom" ||
							 loc === "right-top" ||
							 loc === "right-middle" ||
							 loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent$$1
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if(content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(bleedTop, bleedRight, bleedBottom, bleedLeft, pageWidthVar, pageHeightVar);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			rules.push(wVar, hVar);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let dimensions = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});


			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if(centerWidth === "none" || centerWidth === "auto") {
						if(!leftContent && !rightContent){
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						}else if(leftContent){
							if(!rightContent){
								if(leftWidth !== "none" && leftWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								}else{
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							}else{
								if(leftWidth !== "none" && leftWidth !== "auto"){
									if(rightWidth !== "none" && rightWidth !== "auto"){
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									}else{
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								}else{
									if(rightWidth !== "none" && rightWidth !== "auto"){
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									}else{
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if(newcenterWidth > 40){
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										}else{
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						}else{
							if(rightWidth !== "none" && rightWidth !== "auto"){
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							}else{
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					}else if(centerWidth !== "none" && centerWidth !== "auto"){
						if(leftContent && leftWidth !== "none" && leftWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						}else if(rightContent && rightWidth !== "none" && rightWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						}else{
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				}else{
					if(leftContent){
						if(!rightContent){
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						}else{
							if(leftWidth !== "none" && leftWidth !== "auto"){
								if(rightWidth !== "none" && rightWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								}else{
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							}else{
								if(rightWidth !== "none" && rightWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								}else{
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth  + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					}else{
						if(rightWidth !== "none" && rightWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						}else{
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if(middleHeight === "none" || middleHeight === "auto") {
						if(!topContent && !bottomContent){
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						}else if(topContent){
							if(!bottomContent){
								if(topHeight !== "none" && topHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							}else{
								if(topHeight !== "none" && topHeight !== "auto"){
									if(bottomHeight !== "none" && bottomHeight !== "auto"){
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									}else{
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								}else{
									if(bottomHeight !== "none" && bottomHeight !== "auto"){
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						}else{
							if(bottomHeight !== "none" && bottomHeight !== "auto"){
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					}else{
						if(topContent && topHeight !== "none" && topHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = topHeight +" " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						}else if(bottomContent && bottomHeight !== "none" && bottomHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						}else{
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				}else{
					if(topContent){
						if(!bottomContent){
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						}else{
							if(topHeight !== "none" && topHeight !== "auto"){
								if(bottomHeight !== "none" && bottomHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								}else{
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							}else{
								if(bottomHeight !== "none" && bottomHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								}else{
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					}else{
						if(bottomHeight !== "none" && bottomHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						}else{
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator="+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child$$1 = declaration.value.children.first();
				let value = child$$1.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter$$1 = elementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter$$1) {
								nodeAfter$$1.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter$$1 = elementAfter(elements[i], parsed);

							if (nodeAfter$$1) {
								nodeAfter$$1.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			splits.forEach((split) => {
				let ref = split.dataset.ref;
				let from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}

					this.handleAlignment(from);
				}
			});
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			if (align === "justify" && alignLast === "auto") {
				node.style["text-align-last"] = "justify";
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number: number || 1
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				this.addCounterValues(parsed, counter);
			}
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (var i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
				}
			}
		}

		addCounterValues(parsed, counter) {
			let counterName = counter.name;
			let elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;

			for (var i = 0; i < elements.length; i++) {
				element = elements[i];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					count = parseInt(reset);
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");

					this.styleSheet.insertRule(`[data-ref="${element.dataset.ref}"] { counter-reset: ${counterName} ${count} }`, this.styleSheet.cssRules.length);
					this.styleSheet.insertRule(`[data-ref="${element.dataset.ref}"] { counter-increment: ${counterName} ${increment}}`, this.styleSheet.cssRules.length);

					count += parseInt(increment);

					element.setAttribute("data-counter-"+counterName+"-value", count);
				}

			}
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				let value = reset.datasetCounterPageReset;
				this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-reset: page ${value} }`, this.styleSheet.cssRules.length);
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
				list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + 1);
			}
		}

	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier: identifier,
					value: value,
					selector: selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

				funcNode.children.append(funcNode.children.createItem({
					type: "Identifier",
					loc: null,
					name: "--pagedjs-string-" + identifier
				}));
			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.stringSetSelectors)) {
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					let cssVar;
					if (set.value === "content" || set.value === "content()" || set.value === "content(text)") {
						cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --pagedjs-string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--pagedjs-string-${name}`, `"${cssVar}"`);
						set.first = cssVar;
						fragment.style.setProperty(`--pagedjs-string-${name}`, `"${set.first}"`);
					} else {
						console.warn(set.value + "needs css replacement");
					}
				} else {
					// Use the previous values
					if (set.first) {
						fragment.style.setProperty(`--pagedjs-string-${name}`, `"${set.first}"`);
					}
				}
			}
		}
	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (var i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								pg += 1;

								if (pages[i].contains( element )){
									break;
								}
							}

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${psuedo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${psuedo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				selector.split(",").forEach((s) => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach((name) => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						if (target.style === "content") {
							let selector = UUID();
							selected.setAttribute("data-target-text", selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}

							let textContent = element.textContent.trim().replace(/["']/g, (match) => {
								return "\\" + match;
							}).replace(/[\n]/g, (match) => {
								return "\\00000A";
							});

							// this.styleSheet.insertRule(`[data-target-text="${selector}"]${psuedo} { content: "${element.textContent}" }`, this.styleSheet.cssRules.length);
							this.styleSheet.insertRule(`[data-target-text="${selector}"]${psuedo} { ${target.variable}: "${textContent}" }`, this.styleSheet.cssRules.length);

						}
					} else {
						console.warn("missed target", val);
					}
				});

			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		if (typeof Symbol !== 'function') return false;
		try { } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor() {
			// this.preview = this.getParams("preview") !== "false";

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker();

			// Hooks
			this.hooks = {};

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			let counter = 0;
			this.chunker.on("page", (page) => {
				counter += 1;
				this.emit("page", page);
				if (typeof window.PuppeteerLogger !== "undefined") {
					window.PuppeteerLogger("page", counter);
				}
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();
			let msg = "Rendering " + flow.total + " pages took " + (endTime - startTime) + " milliseconds.";

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", msg, this.size.width && this.size.width.value + this.size.width.unit, this.size.height && this.size.height.value + this.size.height.unit, this.size.orientation, this.size.format);
			if (typeof window.onPagesRendered !== "undefined") {
				window.onPagesRendered(msg, this.size.width && this.size.width.value + this.size.width.unit, this.size.height && this.size.height.value + this.size.height.unit, this.size.orientation, this.size.format);
			}

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);



	var Paged = /*#__PURE__*/Object.freeze({
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined
	};

	let previewer = new Previewer(config.content, config.stylesheets, config.renderTo);


	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview();
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

}));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      const abbreviations = content.querySelectorAll('abbr');
      if(abbreviations.length === 0) return;
      const loaTitle = 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });
}
</script>




<style type="text/css">@font-face {
font-family: 'Montserrat';
font-style: normal;
font-weight: 400;
font-display: swap;
src: local('Montserrat Regular'), local('Montserrat-Regular'), url(data:font/ttf;base64,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LiMgIDyKOCMhWS2wPSywABawESNCILAIQyAuRyNHI2EgYLAgYGawAmIgsABQWLBAYFlmsAFjIyAgPIo4LbA+LCMgLkawAiVGsBFDWFAbUllYIDxZLrEuARQrLbA/LCMgLkawAiVGsBFDWFIbUFlYIDxZLrEuARQrLbBALCMgLkawAiVGsBFDWFAbUllYIDxZIyAuRrACJUawEUNYUhtQWVggPFkusS4BFCstsEEssDgrIyAuRrACJUawEUNYUBtSWVggPFkusS4BFCstsEIssDkriiAgPLAEI0KKOCMgLkawAiVGsBFDWFAbUllYIDxZLrEuARQrsARDLrAuKy2wQyywABawBCWwBCYgICBGI0dhsAojQi5HI0cjYbAJQysjIDwgLiM4sS4BFCstsEQssQgEJUKwABawBCWwBCUgLkcjRyNhILAEI0KxCgBCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgR7AEQ7ACYiCwAFBYsEBgWWawAWNgILABKyCKimEgsAJDYGQjsANDYWRQWLACQ2EbsANDYFmwAyWwAmIgsABQWLBAYFlmsAFjYbACJUZhOCMgPCM4GyEgIEYjR7ABKyNhOCFZsS4BFCstsEUssQA4Ky6xLgEUKy2wRiyxADkrISMgIDywBCNCIzixLgEUK7AEQy6wListsEcssAAVIEewACNCsgABARUUEy6wNCotsEgssAAVIEewACNCsgABARUUEy6wNCotsEkssQABFBOwNSotsEossDcqLbBLLLAAFkUjIC4gRoojYTixLgEUKy2wTCywCCNCsEsrLbBNLLIAAEQrLbBOLLIAAUQrLbBPLLIBAEQrLbBQLLIBAUQrLbBRLLIAAEUrLbBSLLIAAUUrLbBTLLIBAEUrLbBULLIBAUUrLbBVLLMAAABBKy2wViyzAAEAQSstsFcsswEAAEErLbBYLLMBAQBBKy2wWSyzAAABQSstsFosswABAUErLbBbLLMBAAFBKy2wXCyzAQEBQSstsF0ssgAAQystsF4ssgABQystsF8ssgEAQystsGAssgEBQystsGEssgAARistsGIssgABRistsGMssgEARistsGQssgEBRistsGUsswAAAEIrLbBmLLMAAQBCKy2wZyyzAQAAQistsGgsswEBAEIrLbBpLLMAAAFCKy2waiyzAAEBQistsGssswEAAUIrLbBsLLMBAQFCKy2wbSyxADorLrEuARQrLbBuLLEAOiuwPistsG8ssQA6K7A/Ky2wcCywABaxADorsEArLbBxLLEBOiuwPistsHIssQE6K7A/Ky2wcyywABaxATorsEArLbB0LLEAOysusS4BFCstsHUssQA7K7A+Ky2wdiyxADsrsD8rLbB3LLEAOyuwQCstsHgssQE7K7A+Ky2weSyxATsrsD8rLbB6LLEBOyuwQCstsHsssQA8Ky6xLgEUKy2wfCyxADwrsD4rLbB9LLEAPCuwPystsH4ssQA8K7BAKy2wfyyxATwrsD4rLbCALLEBPCuwPystsIEssQE8K7BAKy2wgiyxAD0rLrEuARQrLbCDLLEAPSuwPistsIQssQA9K7A/Ky2whSyxAD0rsEArLbCGLLEBPSuwPistsIcssQE9K7A/Ky2wiCyxAT0rsEArLbCJLLMJBAIDRVghGyMhWUIrsAhlsAMkUHixBQEVRVgwWS0AAAAAS7gAyFJYsQEBjlmwAbkIAAgAY3CxAAdCQAkAa1tLOwAnBwAqsQAHQkAQcAJgCFAIQAg0BiwEHgcHCCqxAAdCQBByAGgGWAZIBjoEMAIlBQcIKrEADkJBCRxAGEAUQBBADUALQAfAAAcACSqxABVCQQkAQABAAEAAQABAAEAAQAAHAAkqsQMARLEkAYhRWLBAiFixA2REsSYBiFFYugiAAAEEQIhjVFixAwBEWVlZWUAQcgBiBlIGQgY2BC4CIAUHDCq4Af+FsASNsQIARLMFZAYAREQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAEgAPgA+ArwAAAIOAAD/PgLC//oCEv/7/zkASABIAD4APgI1AAACPP/6AEgASAA+AD4CNQI1AAAAAAI1Ajz/+v/6AEgASAA+AD4CvAAAAuYCDgAA/z4Cwv/6AucCEv/7/zkASABIAD4APgE7/5wC5gIOAAD/PgE//5gC5wIS//v/PgBIAEgAPgA+AuYBRwLmAg4AAP8+AuoBQwLnAhL/+/85ABgAGAAYABgAAAAIAGYAAwABBAkAAACwAAAAAwABBAkAAQAUALAAAwABBAkAAgAOAMQAAwABBAkAAwA6ANIAAwABBAkABAAkAQwAAwABBAkABQAaATAAAwABBAkABgAkAUoAAwABBAkADgA0AW4AQwBvAHAAeQByAGkAZwBoAHQAIAAyADAAMQAxACAAVABoAGUAIABNAG8AbgB0AHMAZQByAHIAYQB0ACAAUAByAG8AagBlAGMAdAAgAEEAdQB0AGgAbwByAHMAIAAoAGgAdAB0AHAAcwA6AC8ALwBnAGkAdABoAHUAYgAuAGMAbwBtAC8ASgB1AGwAaQBlAHQAYQBVAGwAYQAvAE0AbwBuAHQAcwBlAHIAcgBhAHQAKQBNAG8AbgB0AHMAZQByAHIAYQB0AFIAZQBnAHUAbABhAHIANwAuADIAMAAwADsAVQBMAEEAIAA7AE0AbwBuAHQAcwBlAHIAcgBhAHQALQBSAGUAZwB1AGwAYQByAE0AbwBuAHQAcwBlAHIAcgBhAHQAIABSAGUAZwB1AGwAYQByAFYAZQByAHMAaQBvAG4AIAA3AC4AMgAwADAATQBvAG4AdABzAGUAcgByAGEAdAAtAFIAZQBnAHUAbABhAHIAaAB0AHQAcAA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAAIAAAAAAAD/tQAyAAAAAAAAAAAAAAAAAAAAAAAAAAABEwAAAQIAAgADACQAyQDHAGIArQBjAK4AkAAlACYAZAAnAOkAKABlAMgAygDLACkAKgArACwAzADNAM4AzwAtAC4ALwAwADEAZgAyANAA0QBnANMAkQCvALAAMwDtADQANQA2ADcAOADUANUAaADWADkAOgA7ADwA6wA9AQMARABpAGsAbABqAG4AbQCgAEUARgBvAEcA6gBIAHAAcgBzAHEASQBKAEsATADXAHQAdgB3AQQAdQBNAQUATgBPAFAAUQB4AFIAeQB7AHwAegChAH0AsQBTAO4AVABVAFYAiQBXAFgAfgCAAIEAfwBZAFoAWwBcAOwAugBdAQYAwADBAJ0AngEHABMAFAAVABYAFwAYABkAGgAbABwBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8AvAD0APUA9gANAD8AwwCHAB0ADwCrAAQAowAGABEAIgCiAAUACgAeABIAQgEgASEAXgBgAD4AQAALAAwAswCyABABIgCpAKoAvgC/AMUAtAC1ALYAtwDEASMBJAElAIQAvQAHASYAhQCWAScADgDvAPAAuAAgACEAHwCTAGEApAEoAAgBKQEqACMACQCIAIYAiwCKAIwAgwBfAOgAQQErASwBLQEuAS8BMAExATIBMwE0ATUBNgE3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgCNAN4A2ACOAEMA2gDdANkETlVMTBBJYWN1dGVfSi5sb2NsTkxECWkubG9jbFRSSwd1bmkwMjM3EGlhY3V0ZV9qLmxvY2xOTEQHdW5pMDNCQwl6ZXJvLmRub20Ib25lLmRub20IdHdvLmRub20KdGhyZWUuZG5vbQlmb3VyLmRub20JZml2ZS5kbm9tCHNpeC5kbm9tCnNldmVuLmRub20KZWlnaHQuZG5vbQluaW5lLmRub20JemVyby5udW1yCG9uZS5udW1yCHR3by5udW1yCnRocmVlLm51bXIJZm91ci5udW1yCWZpdmUubnVtcghzaXgubnVtcgpzZXZlbi5udW1yCmVpZ2h0Lm51bXIJbmluZS5udW1yB3VuaTAwQjkHdW5pMDBCMgd1bmkwMEIzB3VuaTIwNzQbcGVyaW9kY2VudGVyZWQubG9jbENBVC5jYXNlFnBlcmlvZGNlbnRlcmVkLmxvY2xDQVQHdW5pMDBBRAd1bmkwMEEwB3VuaTIwMDkHdW5pMjAwQgRFdXJvB3VuaTIyMTUHdW5pMDBCNQdhcnJvd3VwCWFycm93ZG93bgZtaW51dGUGc2Vjb25kB3VuaTAzMDgHdW5pMDMwNwlncmF2ZWNvbWIJYWN1dGVjb21iB3VuaTAzMDIHdW5pMDMwQQl0aWxkZWNvbWIHdW5pMDMwNAd1bmkwMzI3B3VuaTAzMzgMdW5pMDMwOC5jYXNlDmdyYXZlY29tYi5jYXNlDmFjdXRlY29tYi5jYXNlDHVuaTAzMDIuY2FzZQ50aWxkZWNvbWIuY2FzZQx1bmkwMzM1LmNhc2UMdW5pMDMzOC5jYXNlCXVuaTAzMDcuaQ51bmkwMzA4Lm5hcnJvdw51bmkwMzAyLm5hcnJvdwd1bmkwMkJDB3VuaTAyQkIAAQAB//8ADwABAAAADAAAAAAAAAACAAwABAAVAAEAFwArAAEALgA2AAEAOAA4AAEAOgA8AAEAPgBFAAEARwBJAAEASwBPAAEAUQBaAAEAXABtAAEAbwB2AAEAeAB7AAEAAQAA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AAEADAAAAAEABgAAAAEAAQAAAAEABQAAAAEAAgAAAAEAAAAAAAEAAwAAAAEABAAAAAEABwAPACAATgCSAJIAkgCSAJIAyACmALQAyADgASgBUAFqAAQAAAABAAgAAQAeAAIACgAUAAEABAA9AAIAHgABAAQAfAACAFoAAQACABoAVQAGAAAAAgAKACQAAwABABQAAQAuAAEAFAABAAAADQABAAEAXQADAAEAGgABABQAAQAaAAEAAAAOAAEAAQCqAAEAAQAgAAEAAAABAAgAAQAGAAUAAQABAFMAAQAAAAEACAABACgACgABAAAAAQAIAAEABv/sAAEAAQC4AAEAAAABAAgAAQAGABQAAgABAIIAiwAAAAYAAAACAAoAIgADAAEAEgABADQAAAABAAAADgABAAEApAADAAEAEgABABwAAAABAAAADgACAAEAjACVAAAAAgABAJYAnwAAAAQAAAABAAgAAQAaAAEACAACAAYADAB9AAIAUwB+AAIAXQABAAEAUAABAAAAAQAIAAIACgACAFQAuwABAAIAUwCqAAEAAAABAAgAAgAkAA8AfwCAAH8AgACMAI0AjgCPAJAAkQCSAJMAlACVALoAAQAPAAQAJAA+AGEAlgCXAJgAmQCaAJsAnACdAJ4AnwCq) format('truetype');
}
@font-face {
font-family: 'Playfair Display';
font-style: normal;
font-weight: 400;
font-display: swap;
src: url(data:font/ttf;base64,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VhEAAAABAAAAATMzLguGZl8PPPUADwPoAAAAANYdT0wAAAAA2La9zf71/w8EuwSHAAAABgACAAAAAAAAAjIAPAJ2//kCdv/5Anb/+QJ2//kCdv/5Anb/+QJ2//kDVv/2Am8AKgKwADUCsAA1AtMAKgLTAAkCYQAqAmEAKgJhACoCYQAqAmEAKgI5ACoCvwA2AvUAKgFTACoChwAqAVMAKgFT/+YBUwAGAVMAAAFG/+wCjwAqAkwAKgJMACoDZwAqAsIAKgLCACoC5QA1AuUANQLlADUC5QA1AuUANQLlADUC5QA1A6AANQJJACoCRAAqAuUANQKIACoCHAA/Am0AHQKqABsCqgAbAqoAGwKqABsCqgAbAnb/+gOJ//kCegAQAk///QJP//0CUgAqApkAKgLlADUB8gAnAfIAJwHyACcB8gAnAfIAJwHyACcB8gAnAukAJwIzAAQB5gAuAeYALgJFADACKgAuAfoALgH6AC4B+gAuAfoALgH6AC4BTAAaAhAACQJMABQBJQAdASUAHQElAB0BJf/dASX/6gElAB0BJQADAjIAEAEL/+YBC//mAiYAFAEeABYBqgAWA3gAHQJVAB0CVQAdAiQALwIkAC8CJAAvAiQALwIkAC8CJAArAiQALwNDADACRQAWAi8AAAIzAC8BvQAdAb8AOAJIABUBYgAEAkUAEAJFABACRQAQAkUAEAJFABAB6f/+AwIAAAIHABUB+P/8Afj//AH4//wB3AAmAjAAHQIkAC8CjQAaA6wAGgOuABoCawAaAm0AGgOAABoEwQAaBMoAGgOYABoEpAAaA4kAGgJrABoCawAaAlcAGgNjABoBzwA5AcYAMgJYADQBcgAvAd8ALwHDACUB7gARAZ8ALQIFADcBlgAbAggANAH9ACUBwAAlAQcAIgFSACMBRAAcAWUADgFBABwBfgAhATkAEAFvAB8BgQAaAcAAJQEHACIBUgAjAUQAHAFlAA4BQQAcAX4AIQE5ABABbwAfAYEAGgEHACIBUgAjAUQAHAHAACUBZQAOAUEAHAF+ACEBOQAQAW8AHwGBABoAPP71ArwAMAK1ADIC6AAzAPwAPgEFAD4BCgBFAR0ASQMtAD4BBgBDAPkAPQHLACABxQAfAQgARAG5AE4B7AA4An0AMAF0ACIBdAAhASYALAEmABABMAAbATAAGgEoAFwBKAAh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//MAgf/zAIL/8wCD//MAhP/zAIX/8wCG//MAh//zAIj/8wCJ//MAiv/zAIv/8wCM//MAjf/zAI7/8wABAJX/7ABMAAH/2wAC/9sAA//bAAT/2wAF/9sABv/bAAf/2wAI/8wACgAAAAsAAAAUAAAAIwAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAAtAAAAPQAAAD7/7gA//+4AQP/uAEH/7gBC/+4AQ//uAET/7gBF/+4AR//rAEj/6wBJ/+sASv/rAEv/6wBM/+sATf/rAE7/6wBP/+sAUP/sAFH/6QBj/+sAZP/rAGX/6wBm/+sAZ//rAGj/6wBp/+sAav/rAG3/6wBv/+4AfQAAAH//6wCA/+wAgf/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/7ACJ/+wAiv/sAIv/7ACM/+wAjf/sAI7/7ACR/+IAkgAAAJP/7wCU/+kAlf+7AJb/7ACX/+8Amv/pAMr/qQAXADD/6gAx//EAMv/xADP/8QA0//EANf/xADb/2gA3/98AOf/iADr/4gB3/+0AeP/tAHr/6wB7/+sAfP/rAJT/6ADa/9YA3P/WAOH/1gDi/9YBDP/WAQ3/1gEO/9YAfgABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAIQAK/+cAC//nAAwAIQANACEADgAhAA8AIQAQACEAEQAhABIAIQATACEAFP/nABUAIQAWACEAFwAhABgAIQAZACEAGgAhABsAIQAcAIIAHQAhAB4AIQAgACEAIQAhACIAIQAj/+cAJP/nACX/5wAm/+cAJ//nACj/5wAp/+cAKv/nACsAIQAsACEALf/nAC4AIQAv//MAPAAhAD3/5wA+/+kAP//pAED/6QBB/+kAQv/pAEP/6QBE/+kARf/pAEf/4wBI/+MASf/jAEr/4wBL/+MATP/jAE3/4wBO/+MAT//jAFD/9QBTAB8AVAAfAFUAHwBWAB8AVwAfAFgAHwBZABEAWv/pAFsAOgBg//IAYf/yAGL/8gBj/+MAZP/jAGX/4wBm/+MAZ//jAGj/4wBp/+MAav/jAG3/4wBu//IAb//rAHH/7wBy/+kAc//pAHT/6QB1/+kAdv/pAHf/7AB4/+wAef/0AH3/8AB+AB8Af//jAID/9QCB//UAgv/1AIP/9QCE//UAhf/1AIb/9QCH//UAiP/1AIn/9QCK//UAi//1AIz/9QCN//UAjv/1AJH/1wCS/+kAk//nAJX/5QCX/90AmP/oAJn/5gCa/+gAzP/mAM7/7AADAM3/5gDP//IA0f/2AG4AAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAB8ACv/wAAv/8AAMAB8ADQAfAA4AHwAPAB8AEAAfABEAHwASAB8AEwAfABT/8AAVAB8AFgAfABcAHwAYAB8AGQAfABoAHwAbAB8AHAB1AB0AHwAeAB8AIAAfACEAHwAiAB8AI//wACT/8AAl//AAJv/wACf/8AAo//AAKf/wACr/8AArAB8ALAAfAC3/8AAuAB8ANgAAADcAAAA5AAAAOgAAADwAHwA9//AAPv/zAD//8wBA//MAQf/zAEL/8wBD//MARP/zAEX/8wBGAAAAR//sAEj/7ABJ/+wASv/sAEv/7ABM/+wATf/sAE7/7ABP/+wAUwAgAFQAIABVACAAVgAgAFcAIABYACAAWQAIAFoAAABbADIAY//sAGT/7ABl/+wAZv/sAGf/7ABo/+wAaf/sAGr/7ABsAAAAbf/sAG//8gBwAAAAcgAAAHMAAAB0AAAAdQAAAHYAAAB3AAAAeAAAAH0AAAB+ACAAf//sAJH/5ACS//YAk//yAJX/8gCX/+kAmP/2AJn/8wCa/+0AzP/yAM7/7wACAM3/7ADP/+8AZQABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACQAVAAr/9AAL//QADAAVAA0AFQAOABUADwAVABAAFQARABUAEgAVABMAFQAU//QAFQAVABYAFQAXABUAGAAVABkAFQAaABUAGwAVABwAdQAdABUAHgAVACAAFQAhABUAIgAVACP/9AAk//QAJf/0ACb/9AAn//QAKP/0ACn/9AAq//QAKwAVACwAFQAt//QALgAVADYAAAA3AAAAOQAAADoAAAA8ABUAPf/0AD7/9AA///QAQP/0AEH/9ABC//QAQ//0AET/9ABF//QAR//wAEj/8ABJ//AASv/wAEv/8ABM//AATf/wAE7/8ABP//AAUwAYAFQAGABVABgAVgAYAFcAGABYABgAWQAYAFr/9gBbADIAY//wAGT/8ABl//AAZv/wAGf/8ABo//AAaf/wAGr/8ABt//AAb//0AHL/9gBz//YAdP/2AHX/9gB2//YAfgAYAH//8ACR/+oAkv/1AJP/8wCV//AAl//xAJn/9ACa//UAzP/2AAcANgAAADgAAAB5AAAAkgAAAJMAAACUAAAAlQAAAAYAHABXADb/sACUAAAAlgAAAJgAAACaAAAABgAcAFgANv+wAJQAAACWAAAAmAAAAJoAAAACADYAAAA4AAAAAQA2//UAAwA2/7EAOAAAAHn/6gAMAFcAAACR//AAkwAAAJQAAACV/7QAlgAAAJf/9gCa//QAyv/WAOP/8AEB/9sBAv/tACcAAf/eAAL/3gAD/94ABP/eAAX/3gAG/94AB//eAAj/2wAw/+gANv/eADf/3wA4//IAOf/fADr/3wBS/+IAXf/iAF7/4gBf/+IAcf/zAHf/5gB4/+YAef/2AHr/5gB7/+YAfP/mAJMAAACUAAAAlf/qAJ3/9gCfAAAApAAAALD/9gDa//AA3P/wAOH/8ADi//ABDP/wAQ3/8AEO//AAAQCU//YAAQCU//EAAQCU/+8AAgCV//EAmf/zAAIAlf/WAJkAAAADAJP/9gCU/+sAlf/yAAQAkv/1AJT/9gCV/9EAmf/1AAEAlf/oAA0AAf/yAAL/8gAD//IABP/yAAX/8gAG//IAB//yAAj/5QA2AAAANwAAADj/7wA5//UAOv/1AC0AAf/iAAL/4gAD/+IABP/iAAX/4gAG/+IAB//iAAj/0wBH//YASP/2AEn/9gBK//YAS//2AEz/9gBN//YATv/2AE//9gBQ//YAUf/1AFcABwBj//YAZP/2AGX/9gBm//YAZ//2AGj/9gBp//YAav/2AG3/9gB///YAgP/2AIH/9gCC//YAg//2AIT/9gCF//YAhv/2AIf/9gCI//YAif/2AIr/9gCL//YAjP/2AI3/9gCO//YABwCR/94Ak//sAJT/5QCV/6YAlgAAAJf/5ACa/+EAAgAcAFsAWwAAAAQAyv/TAOP/7AEB/9UBAv/tAAIMGAAEAAAMgg48ACwAIwAAAAAAAAAA//YAAAAAAAAAAP/0AAAAAP/yAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//UAAP/6AAAAAAAAAAAAAAAAAAAAAP/4AAD/9gAAAAAAAP/wAAD/+v/rAAAAAP/2AAAAAP/vAAD/+AAAAAAAAAAAAAD/4//5AAAAAP/1AAD/+QAAAAAAAAAAAAD/7gAAAAAAAAAAAAD/9QAA/+kAAP/tAAD/9gAA//f/wwAAAAAAAAAA/+7/rv/5//f/7wAA/9X/zv/zAAAAAAAAAAAAAAAA/+wAAAAA//YAAAAAAAD/4gAAAAAAAAAAAAAAAAAA/84AAAAAAAAAAAAAAAAAAAAAAAAAAP/O/84AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/uAAD/+P/7AAAAAP/1AAAAAAAA//EAAAAA//IAAAAA//kAAAAAAAAAAP/yAAAAAAAAAAAAAAAA//gAAP/7//oAAAAAAAAAAAAAAAAAAAAAAAAAAP/vAAD/5//zAAAAAP/6/8gAAAAAAAAAAP/p/67/+wAA//cAAP/f/9IAAAAAAAAAAAAAAAAAAP/5AAAAAAAAAAAAAAAAAAD/7AAA//MAAAAAAAD/9v/SAAAAAAAAAAD/9f/2//wAAP/tAAD/8f/T//sAAAAAAAAAAAAAAAAAAAAAAAD/9wAAAAAAAAAA/+kAAP/q//UAAAAA//f/wgAAAAAAAAAA/+v/7P/3AAD/7gAA/9j/zQAA//YAAAAAAAAAAAAAAAD/6f/4//r/5//x/+T/9AAA/+cAAP/1//H/8f/3AAD/+P/zAAAAAAAAAAD/9//ZAAAAAAAAAAAAAP/oAAD/6AAA/+0AAAAAAAAAAAAAAAAAAAAAAAAAAAAA//UAAAAAAAD/+wAAAAAAAAAAAAD/9v/3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/n/+wAAP/dAAD/yQAAAAD/ewAA//UAAAAAAAAAAAAAAAD/6wAAAAAAAAAA/68AAAAAAAAAAAAA/+cAAP/zAAAAAAAA//H/9//5AAD/+gAA/9QAAP/2/9UAAP/t/+cAAAAA//MAAAAA//MAAAAAAAAAAP/D//IAAAAA//cAAP/3AAD/+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+wAAAAAAAAAAAAAAAAAAAAAAAAAAD/sP+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+4AAAAAAAAAAAAA//YAAP/qAAD/6AAAAAAAAP/1/8QAAAAAAAAAAP/q/+r/+v/1/+8AAP/W/8//8gAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/kAAD/5P/2AAAAAAAA/+wAAP/3/9T/4gAAAAD/6wAA/9j/6QAAAAAAAAAAAAD/9wAAAAD/5gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/3AAD/8wAA//sAAP/rAAD/+f/qAAAAAP/zAAAAAP/tAAD/9QAAAAAAAAAAAAD/3f/4AAAAAP/z//v/+AAAAAAAAAAAAAAAAP/u//b/+P/q//v/9//yAAD/8AAA//T/8//y//UAAAAA//UAAAAAAAAAAP/0//YAAAAAAAAAAAAA/+wAAP/s//r/6wAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/sAAAAAAAAP/E/7oAAAAAAAAAAAAAAAD/xAAAAAAAAP+6/7AAAAAAAAAAAAAAAAAAAAAA/+7/9//5/+v/8//6//EAAP/yAAD/9P/z//P/9AAAAAD/9QAAAAAAAAAA//T/+QAAAAAAAAAAAAD/7AAA/+z/+f/sAAAAAP+9//f/6f/A/+L/z//mAAD/ywAA/8X/+P/i//MAAP/s//r/wP/2AAAAAP/w/34AAAAAAAAAAAAA/8QAAP/DAAD/3AAAAAAAAAAAAAAAAAAAAAAAAP/xAAAAAP/sAAAAAAAA/98AAAAAAAAAAAAAAAAAAAAA//EAAAAA/9wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/+AAAAAAAAAAAAAAAAP/tAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/wAAAAAAAAAAAAAAAAAAAAL//vAAAAAAAAAAAAAAAAAD4AAAAg/+gAAAAAAAAAXAAAAAD/8gAAAB8AAAAAAAAANgAAADsAYAAeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+4AAAAAAAD/8v+vAAAAAAAAAAD/8AAA//QAAAAAAAD/sP/TAAAAAAAAAAAAAAAAAAAAAP/v/+4AAP/4AAD/zAAAAAD/hgAAAAAAAAAAAAAAAAAAAAD/8AAAAAAAAAAA/7IAAAAAAAAAAAAA/+0AAAAAAAAAAAAAAAD/8P/wAAAAAAAA/7EAAAAA/4UAAAAA//gAAAAAAAAAAP/4AAAAAAAAAAAAAP+yAAAAAAAAAAAAAP/vAAAAAAAAAAAAAAAAAAAAAAAA//sAAAAAAAAAAAAAAAAAAP/7AAD/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/+wAAAAAAAAAAAAAAAAAAAAD/zgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/5AAAAAAAAAAAAAP/y/9IAAAAAAAAAAAAAAAD/9AAAAAAAAP/5/8cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/V/+kAAP/yAAD/0f+6AAD/ywAA/8X/+gAAAAAAAAAAAAD/2AAAAAAAAAAA/7sAAAAAAAAAAAAA/+IAAP/0AAAAAAAAAAD/u//5//H/zv/o/8f/3AAA/8UAAP/e//n/1P/tAAD/7//7/8r/9gAAAAD/9/+BAAAAAAAAAAAAAP+4AAD/0QAA/90AAAAA//sAAAAAAAAAAAAA//kAAAAAAAAAAAAAAAD/8AAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAD/+//7AAAAAAAAAAD/9wAAAAAAAAAA//EAAAAA//MAAAAAAAD/+gAAAAAAAAAAAAAAAAAAAAD/9AAA//r/+gAAAAAAAAAAAAAAAAAAAAD/9gAA//r/9gAAAAAAAP/6AAAAAP/1AAAAAP/1AAAAAAAA/84AAAAAAAD/9wAAAAAAAAAA//kAAAAAAAD/+wAAAAAAAP/v/+z//AAAAAAAAP/dAAD/9P/bAAD/5f/sAAAAAP/1AAAAAP/0AAAAAAAAAAD/0P/uAAAAAP/rAAAAAAAAAAAAAAAAAAD/+AAAAAAAAAAAAAAAAAAA/+oAAAAAAAAAAAAAAAD/4QAAAAAAAAAAAAAAAAAAAAD/7AAA//r/3QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/4AAAAAAAAAAAAAAAA/+8AAAAAAAAAAAAAAAAAAAAA//oAAAAA/+wAAP/sACMAAP/YAAAAAAAAAAAAAAAAAAAAAAAAAAD/8AAAAAD/8wAAAAAAAP/xAAAAAAAAAAAAAAAAAAAAAP/vAAAAAP/iAAAAAAAAAAAAAAAAAAIAEQABAAgAAAAKABIACAAUACoAEQAtADUAKAA3ADcAMQA5ADsAMgA9AEkANQBLAFsAQgBdAF4AUwBgAGwAVQBuAG8AYgBxAHgAZAB6AI4AbAC9AMAAgQDSANUAhQDXAOIAiQEMAQ4AlQACAEkAAQAHAAMACAAIAAQACgALABIADAANABMADgASAAQAFAAUAB8AFQAWAAUAFwAXABQAGAAbAAUAHAAcABQAHQAdACAAHgAfABUAIAAgAAUAIQAiABYAIwApAAEAKgAqAAQALQAtAAEALgAuACEALwAvACIAMAAwACMAMQA1AAkANwA3ACQAOQA6ABcAOwA7ACUAPQA9AAEAPgBEAAYARQBFAAcARgBGAAIARwBIABgASQBJACYASwBPAAcAUABQABoAUQBRACcAUgBSAAgAWgBbAAoAXQBdABEAXgBeABAAYABiAAgAYwBpAAIAagBqAAcAawBsAA8AbgBuACgAbwBvACkAcQBxACoAdwB4AAwAegB8AAwAfQB9ACsAfgB+AAoAfwB/AAIAgACAABoAggCCABAAhACEABAAhQCGAA8AhwCHAAgAiACIAAoAiQCJABEAigCKAAgAjQCNAAoAjgCOABEAvQC+AA0AvwDAABkA0gDVAA4A1wDYAA0A2QDZAB4A2gDaAAsA2wDbAB4A3ADcAAsA3QDdABsA3gDeABwA3wDfABsA4ADgABwA4QDiAB0BDAEOAAsAAgA9AAEABwAHAAgACAAYAAkACQABAAoACwAEAAwAEwABABQAFAAEABUAGwABABwAHAAZAB0AHgABACAAIgABACMAKgAEACsALAABAC0ALQAEAC4ALgABAC8ALwAaADAAMAAbADEANQAJADcANwAcADkAOgAQADsAOwAdADwAPAABAD0APQAEAD4ARQAFAEcATwACAFAAUAADAFEAUQAeAFIAUgANAFMAWQAGAFoAWgAIAFsAWwAfAF0AXwANAGAAYgAOAGMAagACAGwAbAASAG0AbQACAG4AbgAOAG8AbwAgAHAAcAASAHEAcQAhAHIAdgAIAHcAeAAXAHoAfAAPAH0AfQAiAH4AfgAGAH8AfwACAIAAjgADAL0AvgAKAL8AwAARAMEAwQAKANIA1QAMANcA2AAKANkA2QAWANoA2gALANsA2wAWANwA3AALAN0A3QATAN4A3gAUAN8A3wATAOAA4AAUAOEA4gAVAQwBDgALAAAAAQAAAAoA8gGgAAJERkxUAA5sYXRuABIAOAAAADQACEFaRSAARENBVCAAVkNSVCAAaEtBWiAAek5MRCAAjFBMSyAAoFRBVCAAslRSSyAAxAAA//8ABQAAAAEAAgADAAwAAP//AAYAAAABAAIAAwAEAAwAAP//AAYAAAABAAIAAwAFAAwAAP//AAYAAAABAAIAAwAGAAwAAP//AAYAAAABAAIAAwAHAAwAAP//AAcAAAABAAIAAwAIAAwADQAA//8ABgAAAAEAAgADAAkADAAA//8ABgAAAAEAAgADAAoADAAA//8ABgAAAAEAAgADAAsADAAOY2FsdABWZG5vbQBcZnJhYwBibGlnYQBsbG9jbABybG9jbAB4bG9jbAB+bG9jbACEbG9jbACKbG9jbACQbG9jbACWbG9jbACcbnVtcgCicmxpZwCoAAAAAQARAAAAAQALAAAAAwAMAA0ADgAAAAEAEwAAAAEABAAAAAEABQAAAAEACAAAAAEAAgAAAAEACQAAAAEAAwAAAAEAAAAAAAEAAQAAAAEACgAAAAEAEgAUALwAvAC8ACoAvABEAHwAnAC8ANABIAD+AQwBIAE4AXYBdgGOAg4CPAABAAAAAQAIAAIACgACAD0AfwABAAIAJABkAAYAAAACAAoAHgADAAAAAgA+ACgAAQA+AAEAAAAGAAMAAAACAEoAFAABAEoAAQAAAAcAAQABAMYABAAAAAEACAABAAgAAQAOAAEAAQBeAAEABABfAAIAxgAEAAAAAQAIAAEACAABAA4AAQABAB4AAQAEAB8AAgDGAAEAAAABAAgAAQAGAAUAAQABAFMABAAAAAEACAABAB4AAgAKABQAAQAEADwAAgAcAAEABAB+AAIAWwABAAIAGABVAAEAAAABAAgAAQAoAAoAAQAAAAEACAABAAb/7wABAAEAygABAAAAAQAIAAEABgAUAAIAAQCRAJoAAAAGAAAAAgAKACIAAwABABIAAQBCAAAAAQAAAA8AAQABALkAAwABABIAAQAqAAAAAQAAABAAAgABAJsApAAAAAEAAAABAAgAAQAG//YAAgABAKUArgAAAAQAAAABAAgAAQBoAAYAEgAcACYAQABUAF4AAQAEAPkAAgELAAEABAD7AAIA9QADAAgADgAUAPgAAgELAPwAAgD1APoAAgDyAAIABgAOAQAAAwDSAPIA/gACANIAAQAEAP0AAgDKAAEABAD/AAIAywABAAYAygDLANIA8wD1AQsABAAAAAEACAABAB4AAgAKABQAAQAEABcAAgAcAAEABABaAAIAWwABAAIAFgBTAAQAAAABAAgAAQCOAAEACAAPACAAKAAwADgAQABIAFAAVgBcAGIAaABuAHQAegCAAIYAAwBQAEYAhwADAFAAUgCBAAMAUABTAIgAAwBQAFsAiQADAFAAXQCCAAMAUABeAIUAAgBGAIAAAgBQAIoAAgBSAIMAAgBTAIsAAgBXAIwAAgBZAI0AAgBbAI4AAgBdAIQAAgBeAAEAAQBQAAEAAQAIAAIAAAAUAAMAAAAkAAJ3Z2h0AQAAAGl0YWwBCAABAAYAEgAeAAEAAAAAAQEBkAAAAAEAAAAAAQQBkAAAAAMAAQAAAQcAAAAAAAEAAAAA) format('truetype');
}

body {
font-family: "Montserrat", sans-serif;
font-weight: 300;
line-height: 1.1;
font-size: 0.8rem;
color: #444;
}

h1,
h2,
h3 {
font-family: "Playfair Display", serif;
color: #000;
}

sup {
font-size: 0.45rem;
font-style: italic;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Erin Grand Cover Letter</h1>
<h2 class="author">Erin Grand</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<div class="from">
<p>Erin Grand<br />
64 W 108th St #6B<br />
New York, NY 10025<br />
Email: <a href="mailto:eringrand@gmail.com" class="email">eringrand@gmail.com</a></p>
</div>
<p>Space Telescope Science Institute<br />
3700 San Martin Drive<br />
Baltimore, MD 21218</p>
<div class="date">
<p>June 23, 2020</p>
</div>
<p>To whom this may concern,</p>
<p>Hello, my name is Erin Grand and I am writing in response to your open position for an Astronomical Data Scientist position at Space Telescope Science Institute, as seen on Twitter. While I was confident from the posting alone that this would be a great next step in my career, discussing the position and expectations with Dr. Arfon Smith and Dr. Ivelina Momcheva cemented it for me. Between my research work and practical experience, I bring a combined 9 years of experience in both data science and astronomy to a role that feels perfectly tailored to all of my interests.</p>
<p>I received both my undergraduate and masters degrees in astronomy from the University of Maryland in 2007 and 2014 respectively. During my course of study, I worked at NASA to create an ultraviolet mosaic of Andromeda<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. This image has been featured on Astronomy Picture of the Day<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> twice since publication. As part of my thesis research, I spent 3 years working with data from the CARMA radio observatory to study dense gas in star forming regions. I also worked with the Education and Public Outreach sector at NASA Goddard Space Flight Center on two projects, the Science on a Sphere data library, and the traveling Hubble Space Telescope museum exhibit.</p>
<p>My research work drove me to pursue a career in data science, because of my love of statistics and coding. Since then I have applied my skills at organizations that have true public good in mind, such as my past work at the Crisis Text Line. While there, I was able to use data to help redefine the application process to bring in the best people to be counselors. At Uncommon Schools, a charter management organization with more than 50 schools, I created several predictive models to help teachers identify students most at risk of not passing state exams.</p>
<p>A driving career goal for me has been to combine my astronomy and data science passions to further science. I’m excited to apply this energy and determination to grow and learn at Space Telescope Science Institute.</p>
<p>Thank you for your consideration.</p>
<p>Sincerely yours,</p>
<p><img src="data:image/png;base64,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" alt="Erin’s signature" /><br />
Erin Grand</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://www.nasa.gov/mission_pages/swift/bursts/uv_andromeda.html" class="uri">https://www.nasa.gov/mission_pages/swift/bursts/uv_andromeda.html</a><a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p><a href="https://apod.nasa.gov/apod/ap101027.html" class="uri">https://apod.nasa.gov/apod/ap101027.html</a><a href="#fnref2" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
